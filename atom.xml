<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Xiqiu-li.github.io</id>
    <title>Xiqiu&apos;s blog</title>
    <updated>2021-01-14T03:29:52.185Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Xiqiu-li.github.io"/>
    <link rel="self" href="https://Xiqiu-li.github.io/atom.xml"/>
    <logo>https://Xiqiu-li.github.io/images/avatar.png</logo>
    <icon>https://Xiqiu-li.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Xiqiu&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[计算的极限]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian/">
        </link>
        <updated>2021-01-13T16:33:00.000Z</updated>
        <content type="html"><![CDATA[<p>计算的极限系列原本是由<a href="https://songshuhui.net/archives/author/fwjmath/">方弦</a>发表在<a href="songshuhui.net">松鼠会</a>的一系列文章，但松鼠会网站因不明原因以无法访问，因此将在此转载此系列文章。</p>
<h2 id="转载">转载</h2>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-ling-luo-ji-yu-tu-ling-ji/">计算的极限（零）：逻辑与图灵机</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-yi-suo-you-ji-qi-de-ji-qi-yu-wu-fa-ji-suan-de-wen-ti/">计算的极限（一）：所有机器的机器，与无法计算的问题</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-er-zi-wo-zhi-she-yu-bu-ke-pan-ding/">计算的极限（二）：自我指涉与不可判定</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-san-han-shu-gou-cheng-de-shi-jie/">计算的极限（三）：函数构成的世界</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-si-ji-jie-ji-suan-de-gui-nie/">计算的极限（四）：机械计算的圭臬</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-wu-you-xian-de-zhang-bi/">计算的极限（五）：有限的障壁</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-liu-wu-qiong-de-bi-an/">计算的极限（六）：无穷的彼岸</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-qi-wan-ru-shen-yu/">计算的极限（七）：宛如神谕</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-ba-fu-hao-de-kuang-jia/">计算的极限（八）：符号的框架</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-jiu-tan-xi-yu-fen-dou/">计算的极限（九）：叹息与奋斗</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-shi-wu-xian-mian-yan-de-ceng-ji/">计算的极限（十）：无限绵延的层级</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-shi-yi-huang-jin-shi-dai/">计算的极限（十一）：黄金时代</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-shi-er-bu-hui-chu-cuo-de-cheng-xu/">计算的极限（十二）：不会出错的程序</a></p>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-shi-san-shu-zi-kong-jian-de-you-ling/">计算的极限（十三）：数字空间的幽灵</a></p>
<h2 id="原始链接">原始链接</h2>
<p><a href="https://songshuhui.net/archives/70194">计算的极限（零）：逻辑与图灵机</a></p>
<p><a href="https://songshuhui.net/archives/75175">计算的极限（一）：所有机器的机器，与无法计算的问题</a></p>
<p><a href="https://songshuhui.net/archives/75957">计算的极限（二）：自我指涉与不可判定</a></p>
<p><a href="https://songshuhui.net/archives/80229">计算的极限（三）：函数构成的世界</a></p>
<p><a href="https://songshuhui.net/archives/85861">计算的极限（四）：机械计算的圭臬</a></p>
<p><a href="https://songshuhui.net/archives/89734">计算的极限（五）：有限的障壁</a></p>
<p><a href="https://songshuhui.net/archives/90745">计算的极限（六）：无穷的彼岸</a></p>
<p><a href="https://songshuhui.net/archives/92392">计算的极限（七）：宛如神谕</a></p>
<p><a href="https://songshuhui.net/archives/93188">计算的极限（八）：符号的框架</a></p>
<p><a href="https://songshuhui.net/archives/93245">计算的极限（九）：叹息与奋斗</a></p>
<p><a href="https://songshuhui.net/archives/93311">计算的极限（十）：无限绵延的层级</a></p>
<p><a href="https://songshuhui.net/archives/93368">计算的极限（十一）：黄金时代</a></p>
<p><a href="https://songshuhui.net/archives/93698">计算的极限（十二）：不会出错的程序</a></p>
<p><a href="https://songshuhui.net/archives/97690">计算的极限（十三）：数字空间的幽灵</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[产生式]]></title>
        <id>https://Xiqiu-li.github.io/post/chan-sheng-shi/</id>
        <link href="https://Xiqiu-li.github.io/post/chan-sheng-shi/">
        </link>
        <updated>2021-01-13T07:22:14.000Z</updated>
        <content type="html"><![CDATA[<p>产生式是POST提出的根据一种规则，计算模型POST机的串替代规则就是产生式。<br>
写作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P\to Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[相继式演算]]></title>
        <id>https://Xiqiu-li.github.io/post/xiang-ji-shi-yan-suan/</id>
        <link href="https://Xiqiu-li.github.io/post/xiang-ji-shi-yan-suan/">
        </link>
        <updated>2021-01-13T02:07:42.000Z</updated>
        <content type="html"><![CDATA[<p>相继式演算式可证明的形式陈述。是一阶逻辑的演绎系统。</p>
<p>「LK系统」「Gentzen系统」</p>
<p>相继式的一般形式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Gamma\vdash\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span></span></span></span>被称作十字转门，读作“产生”或“证明”，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>叫做相继式的前件，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>叫做相继式的后继。<br>
相继式的LHS（左手端）是合取，RHS（右手端）是析取。当LHS为空，此相继式是重言式。</p>
<p>因为在（左边的）的前件中的所有公式都必须为真来获得在（右边的）后继中至少一个公式为真，向任何一端增加公式都导致一个更弱的相继式，而从任何一端去除公式都得到更强的相继式。</p>
<p>多数证明系统都提供从一个相继式到另一个相继式的演绎方式。这些规则都写成在横线上下的相继式列表。这些规则指示如果在横线上的所有相继式都为真，则在横线之下的也都为真。</p>
<p>一个典型的规则是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>α</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>α</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd></mtr></mtable></mfrac></mrow><annotation encoding="application/x-tex">{\Gamma\vdash\Sigma} \over {\begin{matrix} \Gamma,\alpha\vdash\Sigma &amp; \alpha,\Gamma\vdash\Sigma \end{matrix}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.46144em;vertical-align:-1.09em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.26em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.09em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这指示了如果我们可以演绎<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>，则我们也可以演绎它自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>一起。</p>
<p>注意我们通常使用大写的希腊字母来指称（可能为空）公式的列表。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[\Gamma,\Sigma]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">]</span></span></span></span>被用来指示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>的紧缩，就是说，这些出现在要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>中但不重复的那些公式的列表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MarkDown]]></title>
        <id>https://Xiqiu-li.github.io/post/markdown/</id>
        <link href="https://Xiqiu-li.github.io/post/markdown/">
        </link>
        <updated>2021-01-13T01:58:26.000Z</updated>
        <content type="html"><![CDATA[<p>markdown可以和html混合使用<br>
一个很重要的教程是<a href="https://www.w3school.com.cn/">w3school</a></p>
<p>MarkDown输入数学符号<br>
Mathjax<br>
输入<code>$…$</code>显示Latex，<code>$$…$$</code>单独显示。<br>
<code>\Gamma</code>显示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span><br>
<code>$x_{3^2}$</code>显示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><msup><mn>3</mn><mn>2</mn></msup></msub></mrow><annotation encoding="application/x-tex">x_{3^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6081799999999999em;vertical-align:-0.17762em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.52238em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17762em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>=</mo><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2 = b^2 + c^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 4: A  &amp;̲ \to  B \tag{规则…'>A  &amp; \to  B \tag{规则1} \\
&amp; a \tag{规则2} \\
</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<p><strong>粗体</strong><br>
<strong>粗体</strong><br>
<em>斜体</em><br>
<em>斜体</em><br>
<em><strong>粗斜</strong></em></p>
<blockquote>
<p>块引用</p>
</blockquote>
<blockquote>
<p>连续块</p>
</blockquote>
<pre><code>&lt;html&gt;
    &lt;head&gt;
     代码块
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>
<p>分割线</p>
<hr>
<hr>
<hr>
<p>超链接<a href="https://markdown.com.cn" title="最好的markdown教程">Markdown语法</a></p>
<p>引用MarkDown语法<a href="https://markdown.com.cn/basic-syntax/links.html">1</a></p>
<p>图片</p>
<figure data-type="image" tabindex="1"><img src="/assets/img/philly-magic-garden.jpg" alt="这是图片" title="Magic Gardens" loading="lazy"></figure>
<h2 id="reference">reference</h2>
<p><a href="http://www.yinwang.org/blog-cn/2013/04/14/markdown">Markdown 的一些问题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markup Language]]></title>
        <id>https://Xiqiu-li.github.io/post/markup-language/</id>
        <link href="https://Xiqiu-li.github.io/post/markup-language/">
        </link>
        <updated>2021-01-12T15:16:36.000Z</updated>
        <content type="html"><![CDATA[<p>著名的标记语言有</p>
<li>
HTML
</li>
<li>
MarkDown
</li>
<li>
Tex
</li>
<h2 id="html">HTML</h2>
<p>HTML是当代互联网创建网页的通用标记语言，由一系列&lt;&gt;标签进行标记。由3W联盟制定标准。3W还有一个被称作”语义网“的计划，私以为和HTML密切相关。在H5的制定标准中，HTML的标签更倾向于语义描述而不是样式描述。江湖传言中真正的高手直接使用HTML编写自己的博客，而假使遵循“所见即所指”的原则，编写HTML只需要关心文本的内涵，而无需关注他们的显示样式。看似美好，但这里有一个严重问题，就是每次编写一段内容的时候都要输入各种标签，有时还需要标明特定的class或者标签的id，非常繁琐。</p>
<h2 id="markdown">MarkDown</h2>
<p>MarkDown一般使用方式均为翻译为HTML在网页显示。所以一般MarkDown能实现的均可以使用HTML实现。MakrDown属于内容和格式分离的标记语言，因此不能操作一些格式上的问题，想要操作格式需要使用css的技巧。另外MarkDown的官方标准最新更新是在2004年，至今MarkDown虽然被很多平台采用，但不同平台的实现各有不同，因此移植性较差。此外MarkDown还有一些语言本身的问题</p>
<li>
layout语法空格敏感
</li>
<li>
特殊字符选择不合理，如*被用于做标记。
</li>
因MarkDown一般都是转换成HTML使用，因此可尝试自己设计一下修改MarkDown的语法为自己平日编辑做转换。
<h2 id="tex">Tex</h2>
<p>Tex是高德纳发明的一种排版系统，可以输出多种文件格式，可以显示多种符号。纸张的写法在二维平面内不受限制，而计算机只能输入制定编码以特定形式展现，键盘只有有限且固定的键位，因此想要输入各种在纸张时代设计的数学符号公式、化学结构式等复杂的结构，就必须有一套强大的编辑系统。只有如此才能在计算机内编辑出想要的文章。而Tex的问题正是在于其复杂的功能所带来的学习难度。</p>
<h2 id="总结">总结</h2>
<p>虽然HTML提供了<code>&lt;math&gt;</code>标签做各种数学公式的表示，但仍有不足，而MarkDown自然不会更好。现有很多平台的编辑器疑似采用了Tex引擎，在用户输入内容后，后台将用户的源码中的公式按既定语法转换成图片后嵌入HTML，这对于自己写博客来说似乎有点糟糕。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[[翻译]Micro Parser Combinators]]></title>
        <id>https://Xiqiu-li.github.io/post/micro-parser-combinators/</id>
        <link href="https://Xiqiu-li.github.io/post/micro-parser-combinators/">
        </link>
        <updated>2021-01-11T15:52:23.000Z</updated>
        <content type="html"><![CDATA[<p><a href="https://github.com/orangeduck/mpc">原文</a></p>
<h2 id="关于">关于</h2>
<p>mpc是一个轻量级的、强力的解析器组合子C语言库</p>
<p>如果你在做下面这些事，可能你会对mpc感兴趣<br>
实现一门新语言<br>
创造一种新的数据格式<br>
解析现有的程序语言<br>
嵌入领域特定语言<br>
实施格林斯潘的第十条规则</p>
<h2 id="特性">特性</h2>
<p>MPC<br>
「泛型」<br>
「预测，递归下降」<br>
易于集成（在标准C中<br>
自动生成错误消息<br>
正则表达式解析器生成器<br>
语言/语法解析器生成器</p>
<h2 id="备选方案">备选方案</h2>
<p>当前基于C的解析器组合子库的备选方案是Ceslum3的分支，mpc支持很多他不支持的特性。也克服了很多潜在问题。<br>
mpc适用于通用类型「？泛型？」<br>
mpc不依赖「Boehm-Demers-Weiser」垃圾回收<br>
MPC不使用setjmp和longjmp进行错误<br>
MPC不污染名字空间</p>
<h1 id="快速开始">快速开始</h1>
<p>这里是如何使用MPC来创建一个基本数学表达式语言的解析器</p>
<pre><code>mpc_parser_t *Expr  = mpc_new(&quot;expression&quot;);
mpc_parser_t *Prod  = mpc_new(&quot;product&quot;);
mpc_parser_t *Value = mpc_new(&quot;value&quot;);
mpc_parser_t *Maths = mpc_new(&quot;maths&quot;);

mpca_lang(MPCA_LANG_DEFAULT,
  &quot; expression : &lt;product&gt; (('+' | '-') &lt;product&gt;)*; &quot;
  &quot; product    : &lt;value&gt;   (('*' | '/')   &lt;value&gt;)*; &quot;
  &quot; value      : /[0-9]+/ | '(' &lt;expression&gt; ')';    &quot;
  &quot; maths      : /^/ &lt;expression&gt; /$/;               &quot;,
  Expr, Prod, Value, Maths, NULL);

mpc_result_t r;

if (mpc_parse(&quot;input&quot;, input, Maths, &amp;r)) {
  mpc_ast_print(r.output);
  mpc_ast_delete(r.output);
} else {
  mpc_err_print(r.error);
  mpc_err_delete(r.error);
}

mpc_cleanup(4, Expr, Prod, Value, Maths);
</code></pre>
<p>如果你想为<code>(4 * 2 * 11 + 2) - 5</code>字符串设置input，打印的输出会是这样。</p>
<pre><code>&gt;
  regex
  expression|&gt;
    value|&gt;
      char:1:1 '('
      expression|&gt;
        product|&gt;
          value|regex:1:2 '4'
          char:1:4 '*'
          value|regex:1:6 '2'
          char:1:8 '*'
          value|regex:1:10 '11'
        char:1:13 '+'
        product|value|regex:1:15 '2'
      char:1:16 ')'
    char:1:18 '-'
    product|value|regex:1:20 '5'
  regex
</code></pre>
<h1 id="开始">开始</h1>
<h2 id="介绍">介绍</h2>
<p>解析器组合子是对特定语言进行结构化编码。他们可以使用直观的运算符组合在一起，创建越来越复杂的解析器。使用这些符号可以轻松、快速、高效的解析和处理语法和语言。</p>
<p>解析器组合子背后的技巧是观察到，通过以一种特殊的方式构造库，可以使构建解析器组合子看起来像是自己编写语法。 因此，用户不必描述如何解析一种语言，而只需指定语言本身，该库就会得出如何解析它的方式……就像是在魔术一样！</p>
<p>mpc可以在此模式下使用，或者如上例所示，您可以直接将语法指定为字符串或文件。</p>
<h2 id="基本解析器">基本解析器</h2>
<h3 id="字符串解析器">字符串解析器</h3>
<p>以下所有函数构造类型为<code>mpc_parser_t *</code>的解析器。 所有这些解析器都返回一个新分配的<code>char *</code>，其中包含他们设法匹配的字符。 如果不成功，它们将返回错误。 它们具有以下功能。</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_any(void);
</code></pre>
<p>匹配任意单个字符</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_char(char c);
</code></pre>
<p>匹配单个给定字符<code>c</code></p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_range(char s, char e);
</code></pre>
<p>匹配范围从<code>s</code>到<code>e</code>的任何单个给定字符</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_oneof(const char *s);
</code></pre>
<p>匹配字符串<code>s</code>中的任何单个给定字符</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_noneof(const char *s);
</code></pre>
<p>匹配不在字符串<code>s</code>中的任何单个给定字符</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_satisfy(int(*f)(char));
</code></pre>
<p>匹配任何满足函数<code>f</code>的单个给定字符</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_string(const char *s);
</code></pre>
<p>完全匹配<code>s</code>字符串</p>
<h3 id="其他解析器">其他解析器</h3>
<p>Several other functions exist that construct parsers with some other special functionality.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_pass(void);
</code></pre>
<p>Consumes no input, always successful, returns <code>NULL</code></p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_fail(const char *m);
mpc_parser_t *mpc_failf(const char *fmt, ...);
</code></pre>
<p>Consumes no input, always fails with message <code>m</code> or formatted string <code>fmt</code>.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_lift(mpc_ctor_t f);
</code></pre>
<p>Consumes no input, always successful, returns the result of function <code>f</code></p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_lift_val(mpc_val_t *x);
</code></pre>
<p>Consumes no input, always successful, returns <code>x</code></p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_state(void);
</code></pre>
<p>Consumes no input, always successful, returns a copy of the parser state as a <code>mpc_state_t *</code>. This state is newly allocated and so needs to be released with <code>free</code> when finished with.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_anchor(int(*f)(char,char));
</code></pre>
<p>Consumes no input. Successful when function <code>f</code> returns true. Always returns <code>NULL</code>.</p>
<p>Function <code>f</code> is a <em>anchor</em> function. It takes as input the last character parsed, and the next character in the input, and returns success or failure. This function can be set by the user to ensure some condition is met. For example to test that the input is at a boundary between words and non-words.</p>
<p>At the start of the input the first argument is set to <code>'\0'</code>. At the end of the input the second argument is set to <code>'\0'</code>.</p>
<h2 id="解析中">解析中</h2>
<p>Once you've build a parser, you can run it on some input using one of the following functions. These functions return <code>1</code> on success and <code>0</code> on failure. They output either the result, or an error to a <code>mpc_result_t</code> variable. This type is defined as follows.</p>
<pre><code class="language-c">typedef union {
  mpc_err_t *error;
  mpc_val_t *output;
} mpc_result_t;
</code></pre>
<p>where <code>mpc_val_t *</code> is synonymous with <code>void *</code> and simply represents some pointer to data - the exact type of which is dependant on the parser.</p>
<hr>
<pre><code class="language-c">int mpc_parse(const char *filename, const char *string, mpc_parser_t *p, mpc_result_t *r);
</code></pre>
<p>Run a parser on some string.</p>
<hr>
<pre><code class="language-c">int mpc_parse_file(const char *filename, FILE *file, mpc_parser_t *p, mpc_result_t *r);
</code></pre>
<p>Run a parser on some file.</p>
<hr>
<pre><code class="language-c">int mpc_parse_pipe(const char *filename, FILE *pipe, mpc_parser_t *p, mpc_result_t *r);
</code></pre>
<p>Run a parser on some pipe (such as <code>stdin</code>).</p>
<hr>
<pre><code class="language-c">int mpc_parse_contents(const char *filename, mpc_parser_t *p, mpc_result_t *r);
</code></pre>
<p>Run a parser on the contents of some file.</p>
<h2 id="组合子">组合子</h2>
<p>Combinators are functions that take one or more parsers and return a new parser of some given functionality.</p>
<p>These combinators work independently of exactly what data type the parser(s) supplied as input return. In languages such as Haskell ensuring you don't input one type of data into a parser requiring a different type is done by the compiler. But in C we don't have that luxury. So it is at the discretion of the programmer to ensure that he or she deals correctly with the outputs of different parser types.</p>
<p>A second annoyance in C is that of manual memory management. Some parsers might get half-way and then fail. This means they need to clean up any partial result that has been collected in the parse. In Haskell this is handled by the Garbage Collector, but in C these combinators will need to take <em>destructor</em> functions as input, which say how clean up any partial data that has been collected.</p>
<p>Here are the main combinators and how to use then.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_expect(mpc_parser_t *a, const char *e);
mpc_parser_t *mpc_expectf(mpc_parser_t *a, const char *fmt, ...);
</code></pre>
<p>Returns a parser that runs <code>a</code>, and on success returns the result of <code>a</code>, while on failure reports that <code>e</code> was expected.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_apply(mpc_parser_t *a, mpc_apply_t f);
mpc_parser_t *mpc_apply_to(mpc_parser_t *a, mpc_apply_to_t f, void *x);
</code></pre>
<p>Returns a parser that applies function <code>f</code> (optionality taking extra input <code>x</code>) to the result of parser <code>a</code>.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_check(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *e);
mpc_parser_t *mpc_check_with(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *e);
mpc_parser_t *mpc_checkf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_t f, const char *fmt, ...);
mpc_parser_t *mpc_check_withf(mpc_parser_t *a, mpc_dtor_t da, mpc_check_with_t f, void *x, const char *fmt, ...);
</code></pre>
<p>Returns a parser that applies function <code>f</code> (optionally taking extra input <code>x</code>) to the result of parser <code>a</code>. If <code>f</code> returns non-zero, then the parser succeeds and returns the value of <code>a</code> (possibly modified by <code>f</code>). If <code>f</code> returns zero, then the parser fails with message <code>e</code>, and the result of <code>a</code> is destroyed with the destructor <code>da</code>.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_not(mpc_parser_t *a, mpc_dtor_t da);
mpc_parser_t *mpc_not_lift(mpc_parser_t *a, mpc_dtor_t da, mpc_ctor_t lf);
</code></pre>
<p>Returns a parser with the following behaviour. If parser <code>a</code> succeeds, then it fails and consumes no input. If parser <code>a</code> fails, then it succeeds, consumes no input and returns <code>NULL</code> (or the result of lift function <code>lf</code>). Destructor <code>da</code> is used to destroy the result of <code>a</code> on success.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_maybe(mpc_parser_t *a);
mpc_parser_t *mpc_maybe_lift(mpc_parser_t *a, mpc_ctor_t lf);
</code></pre>
<p>Returns a parser that runs <code>a</code>. If <code>a</code> is successful then it returns the result of <code>a</code>. If <code>a</code> is unsuccessful then it succeeds, but returns <code>NULL</code> (or the result of <code>lf</code>).</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_many(mpc_fold_t f, mpc_parser_t *a);
</code></pre>
<p>Runs <code>a</code> zero or more times until it fails. Results are combined using fold function <code>f</code>. See the <em>Function Types</em> section for more details.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_many1(mpc_fold_t f, mpc_parser_t *a);
</code></pre>
<p>Runs <code>a</code> one or more times until it fails. Results are combined with fold function <code>f</code>.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_count(int n, mpc_fold_t f, mpc_parser_t *a, mpc_dtor_t da);
</code></pre>
<p>Runs <code>a</code> exactly <code>n</code> times. If this fails, any partial results are destructed with <code>da</code>. If successful results of <code>a</code> are combined using fold function <code>f</code>.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_or(int n, ...);
</code></pre>
<p>Attempts to run <code>n</code> parsers in sequence, returning the first one that succeeds. If all fail, returns an error.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_and(int n, mpc_fold_t f, ...);
</code></pre>
<p>Attempts to run <code>n</code> parsers in sequence, returning the fold of the results using fold function <code>f</code>. First parsers must be specified, followed by destructors for each parser, excluding the final parser. These are used in case of partial success. For example: <code>mpc_and(3, mpcf_strfold, mpc_char('a'), mpc_char('b'), mpc_char('c'), free, free);</code> would attempt to match <code>'a'</code> followed by <code>'b'</code> followed by <code>'c'</code>, and if successful would concatenate them using <code>mpcf_strfold</code>. Otherwise would use <code>free</code> on the partial results.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_predictive(mpc_parser_t *a);
</code></pre>
<p>Returns a parser that runs <code>a</code> with backtracking disabled. This means if <code>a</code> consumes more than one character, it will not be reverted, even on failure. Turning backtracking off has good performance benefits for grammars which are <code>LL(1)</code>. These are grammars where the first character completely determines the parse result - such as the decision of parsing either a C identifier, number, or string literal. This option should not be used for non <code>LL(1)</code> grammars or it will produce incorrect results or crash the parser.</p>
<p>Another way to think of <code>mpc_predictive</code> is that it can be applied to a parser (for a performance improvement) if either successfully parsing the first character will result in a completely successful parse, or all of the referenced sub-parsers are also <code>LL(1)</code>.</p>
<h2 id="function-types">Function Types</h2>
<p>The combinator functions take a number of special function types as function pointers. Here is a short explanation of those types are how they are expected to behave. It is important that these behave correctly otherwise it is easy to introduce memory leaks or crashes into the system.</p>
<hr>
<pre><code class="language-c">typedef void(*mpc_dtor_t)(mpc_val_t*);
</code></pre>
<p>Given some pointer to a data value it will ensure the memory it points to is freed correctly.</p>
<hr>
<pre><code class="language-c">typedef mpc_val_t*(*mpc_ctor_t)(void);
</code></pre>
<p>Returns some data value when called. It can be used to create <em>empty</em> versions of data types when certain combinators have no known default value to return. For example it may be used to return a newly allocated empty string.</p>
<hr>
<pre><code class="language-c">typedef mpc_val_t*(*mpc_apply_t)(mpc_val_t*);
typedef mpc_val_t*(*mpc_apply_to_t)(mpc_val_t*,void*);
</code></pre>
<p>This takes in some pointer to data and outputs some new or modified pointer to data, ensuring to free the input data if it is no longer used. The <code>apply_to</code> variation takes in an extra pointer to some data such as global state.</p>
<hr>
<pre><code class="language-c">typedef int(*mpc_check_t)(mpc_val_t**);
typedef int(*mpc_check_with_t)(mpc_val_t**,void*);
</code></pre>
<p>This takes in some pointer to data and outputs 0 if parsing should stop with an error. Additionally, this may change or free the input data. The <code>check_with</code> variation takes in an extra pointer to some data such as global state.</p>
<hr>
<pre><code class="language-c">typedef mpc_val_t*(*mpc_fold_t)(int,mpc_val_t**);
</code></pre>
<p>This takes a list of pointers to data values and must return some combined or folded version of these data values. It must ensure to free any input data that is no longer used once the combination has taken place.</p>
<h1 id="案例研究-标识符">案例研究-标识符</h1>
<h2 id="组合子方法">组合子方法</h2>
<p>Using the above combinators we can create a parser that matches a C identifier.</p>
<p>When using the combinators we need to supply a function that says how to combine two <code>char *</code>.</p>
<p>For this we build a fold function that will concatenate zero or more strings together. For this sake of this tutorial we will write it by hand, but this (as well as many other useful fold functions), are actually included in <em>mpc</em> under the <code>mpcf_*</code> namespace, such as <code>mpcf_strfold</code>.</p>
<pre><code class="language-c">mpc_val_t *strfold(int n, mpc_val_t **xs) {
  char *x = calloc(1, 1);
  int i;
  for (i = 0; i &lt; n; i++) {
    x = realloc(x, strlen(x) + strlen(xs[i]) + 1);
    strcat(x, xs[i]);
    free(xs[i]);
  }
  return x;
}
</code></pre>
<p>We can use this to specify a C identifier, making use of some combinators to say how the basic parsers are combined.</p>
<pre><code class="language-c">mpc_parser_t *alpha = mpc_or(2, mpc_range('a', 'z'), mpc_range('A', 'Z'));
mpc_parser_t *digit = mpc_range('0', '9');
mpc_parser_t *underscore = mpc_char('_');

mpc_parser_t *ident = mpc_and(2, strfold,
  mpc_or(2, alpha, underscore),
  mpc_many(strfold, mpc_or(3, alpha, digit, underscore)),
  free);

/* Do Some Parsing... */

mpc_delete(ident);
</code></pre>
<p>Notice that previous parsers are used as input to new parsers we construct from the combinators. Note that only the final parser <code>ident</code> must be deleted. When we input a parser into a combinator we should consider it to be part of the output of that combinator.</p>
<p>Because of this we shouldn't create a parser and input it into multiple places, or it will be doubly freed.</p>
<h2 id="正则方法">正则方法</h2>
<p>There is an easier way to do this than the above method. <em>mpc</em> comes with a handy regex function for constructing parsers using regex syntax. We can specify an identifier using a regex pattern as shown below.</p>
<pre><code class="language-c">mpc_parser_t *ident = mpc_re(&quot;[a-zA-Z_][a-zA-Z_0-9]*&quot;);

/* Do Some Parsing... */

mpc_delete(ident);
</code></pre>
<h2 id="库方法">库方法</h2>
<p>Although if we really wanted to create a parser for C identifiers, a function for creating this parser comes included in <em>mpc</em> along with many other common parsers.</p>
<pre><code class="language-c">mpc_parser_t *ident = mpc_ident();

/* Do Some Parsing... */

mpc_delete(ident);
</code></pre>
<h1 id="解析器参考">解析器参考</h1>
<p>Building parsers in the above way can have issues with self-reference or cyclic-reference. To overcome this we can separate the construction of parsers into two different steps. Construction and Definition.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_new(const char *name);
</code></pre>
<p>This will construct a parser called <code>name</code> which can then be used as input to others, including itself, without fear of being deleted. Any parser created using <code>mpc_new</code> is said to be <em>retained</em>. This means it will behave differently to a normal parser when referenced. When deleting a parser that includes a <em>retained</em> parser, the <em>retained</em> parser will not be deleted along with it. To delete a retained parser <code>mpc_delete</code> must be used on it directly.</p>
<p>A <em>retained</em> parser can then be <em>defined</em> using...</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_define(mpc_parser_t *p, mpc_parser_t *a);
</code></pre>
<p>This assigns the contents of parser <code>a</code> to <code>p</code>, and deletes <code>a</code>. With this technique parsers can now reference each other, as well as themselves, without trouble.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_undefine(mpc_parser_t *p);
</code></pre>
<p>A final step is required. Parsers that reference each other must all be undefined before they are deleted. It is important to do any undefining before deletion. The reason for this is that to delete a parser it must look at each sub-parser that is used by it. If any of these have already been deleted a segfault is unavoidable - even if they were retained beforehand.</p>
<hr>
<pre><code class="language-c">void mpc_cleanup(int n, ...);
</code></pre>
<p>To ease the task of undefining and then deleting parsers <code>mpc_cleanup</code> can be used. It takes <code>n</code> parsers as input, and undefines them all, before deleting them all.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_copy(mpc_parser_t *a);
</code></pre>
<p>This function makes a copy of a parser <code>a</code>. This can be useful when you want to<br>
use a parser as input for some other parsers multiple times without retaining<br>
it.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpc_re(const char *re);
mpc_parser_t *mpc_re_mode(const char *re, int mode);
</code></pre>
<p>This function takes as input the regular expression <code>re</code> and builds a parser<br>
for it. With the <code>mpc_re_mode</code> function optional mode flags can also be given.<br>
Available flags are <code>MPC_RE_MULTILINE</code> / <code>MPC_RE_M</code> where the start of input<br>
character <code>^</code> also matches the beginning of new lines and the end of input <code>$</code><br>
character also matches new lines, and <code>MPC_RE_DOTALL</code> / <code>MPC_RE_S</code> where the<br>
any character token <code>.</code> also matches newlines (by default it doesn't).</p>
<h1 id="库参考">库参考</h1>
<h2 id="通用解析器">通用解析器</h2>
<table>
  <tr><td><code>mpc_soi</code></td><td>Matches only the start of input, returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_eoi</code></td><td>Matches only the end of input, returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_boundary</code></td><td>Matches only the boundary between words, returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_boundary_newline</code></td><td>Matches the start of a new line, returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_whitespace</code></td><td>Matches any whitespace character <code>" \f\n\r\t\v"</code></td></tr>
  <tr><td><code>mpc_whitespaces</code></td><td>Matches zero or more whitespace characters</td></tr>
  <tr><td><code>mpc_blank</code></td><td>Matches whitespaces and frees the result, returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_newline</code></td><td>Matches <code>'\n'</code></td></tr>
  <tr><td><code>mpc_tab</code></td><td>Matches <code>'\t'</code></td></tr>
  <tr><td><code>mpc_escape</code></td><td>Matches a backslash followed by any character</td></tr>
  <tr><td><code>mpc_digit</code></td><td>Matches any character in the range <code>'0'</code> - <code>'9'</code></td></tr>
  <tr><td><code>mpc_hexdigit</code></td><td>Matches any character in the range <code>'0</code> - <code>'9'</code> as well as <code>'A'</code> - <code>'F'</code> and <code>'a'</code> - <code>'f'</code></td></tr>
  <tr><td><code>mpc_octdigit</code></td><td>Matches any character in the range <code>'0'</code> - <code>'7'</code></td></tr>
  <tr><td><code>mpc_digits</code></td><td>Matches one or more digit</td></tr>
  <tr><td><code>mpc_hexdigits</code></td><td>Matches one or more hexdigit</td></tr>
  <tr><td><code>mpc_octdigits</code></td><td>Matches one or more octdigit</td></tr>
  <tr><td><code>mpc_lower</code></td><td>Matches any lower case character</td></tr>
  <tr><td><code>mpc_upper</code></td><td>Matches any upper case character</td></tr>
  <tr><td><code>mpc_alpha</code></td><td>Matches any alphabet character</td></tr>
  <tr><td><code>mpc_underscore</code></td><td>Matches <code>'_'</code></td></tr>
  <tr><td><code>mpc_alphanum</code></td><td>Matches any alphabet character, underscore or digit</td></tr>
  <tr><td><code>mpc_int</code></td><td>Matches digits and returns an <code>int*</code></td></tr>
  <tr><td><code>mpc_hex</code></td><td>Matches hexdigits and returns an <code>int*</code></td></tr>
  <tr><td><code>mpc_oct</code></td><td>Matches octdigits and returns an <code>int*</code></td></tr>
  <tr><td><code>mpc_number</code></td><td>Matches <code>mpc_int</code>, <code>mpc_hex</code> or <code>mpc_oct</code></td></tr>
  <tr><td><code>mpc_real</code></td><td>Matches some floating point number as a string</td></tr>
  <tr><td><code>mpc_float</code></td><td>Matches some floating point number and returns a <code>float*</code></td></tr>
  <tr><td><code>mpc_char_lit</code></td><td>Matches some character literal surrounded by <code>'</code></td></tr>
  <tr><td><code>mpc_string_lit</code></td><td>Matches some string literal surrounded by <code>"</code></td></tr>
  <tr><td><code>mpc_regex_lit</code></td><td>Matches some regex literal surrounded by <code>/</code></td></tr>
  <tr><td><code>mpc_ident</code></td><td>Matches a C style identifier</td></tr>
</table>
<h2 id="有用的解析器">有用的解析器</h2>
<table>
  <tr><td><code>mpc_startswith(mpc_parser_t *a);</code></td><td>Matches the start of input followed by <code>a</code></td></tr>
  <tr><td><code>mpc_endswith(mpc_parser_t *a, mpc_dtor_t da);</code></td><td>Matches <code>a</code> followed by the end of input</td></tr>
  <tr><td><code>mpc_whole(mpc_parser_t *a, mpc_dtor_t da);</code></td><td>Matches the start of input, <code>a</code>, and the end of input</td></tr>
  <tr><td><code>mpc_stripl(mpc_parser_t *a);</code></td><td>Matches <code>a</code> first consuming any whitespace to the left</td></tr>
  <tr><td><code>mpc_stripr(mpc_parser_t *a);</code></td><td>Matches <code>a</code> then consumes any whitespace to the right</td></tr>
  <tr><td><code>mpc_strip(mpc_parser_t *a);</code></td><td>Matches <code>a</code> consuming any surrounding whitespace</td></tr>
  <tr><td><code>mpc_tok(mpc_parser_t *a);</code></td><td>Matches <code>a</code> and consumes any trailing whitespace</td></tr>
  <tr><td><code>mpc_sym(const char *s);</code></td><td>Matches string <code>s</code> and consumes any trailing whitespace</td></tr>
  <tr><td><code>mpc_total(mpc_parser_t *a, mpc_dtor_t da);</code></td><td>Matches the whitespace consumed <code>a</code>, enclosed in the start and end of input</td></tr>
  <tr><td><code>mpc_between(mpc_parser_t *a, mpc_dtor_t ad, <br /> const char *o, const char *c);</code></td><td> Matches <code>a</code> between strings <code>o</code> and <code>c</code></td></tr>
  <tr><td><code>mpc_parens(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>"("</code> and <code>")"</code></td></tr>
  <tr><td><code>mpc_braces(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>"<"</code> and <code>">"</code></td></tr>
  <tr><td><code>mpc_brackets(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>"{"</code> and <code>"}"</code></td></tr>
  <tr><td><code>mpc_squares(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between <code>"["</code> and <code>"]"</code></td></tr>
  <tr><td><code>mpc_tok_between(mpc_parser_t *a, mpc_dtor_t ad, <br /> const char *o, const char *c);</code></td><td>Matches <code>a</code> between <code>o</code> and <code>c</code>, where <code>o</code> and <code>c</code> have their trailing whitespace striped.</td></tr>
  <tr><td><code>mpc_tok_parens(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>"("</code> and <code>")"</code></td></tr>
  <tr><td><code>mpc_tok_braces(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>"<"</code> and <code>">"</code></td></tr>
  <tr><td><code>mpc_tok_brackets(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>"{"</code> and <code>"}"</code></td></tr>
  <tr><td><code>mpc_tok_squares(mpc_parser_t *a, mpc_dtor_t ad);</code></td><td>Matches <code>a</code> between trailing whitespace consumed <code>"["</code> and <code>"]"</code></td></tr>
</table>
<h2 id="apply-functions">Apply Functions</h2>
<table>
  <tr><td><code>void mpcf_dtor_null(mpc_val_t *x);</code></td><td>Empty destructor. Does nothing</td></tr>
  <tr><td><code>mpc_val_t *mpcf_ctor_null(void);</code></td><td>Returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_ctor_str(void);</code></td><td>Returns <code>""</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_free(mpc_val_t *x);</code></td><td>Frees <code>x</code> and returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_int(mpc_val_t *x);</code></td><td>Converts a decimal string <code>x</code> to an <code>int*</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_hex(mpc_val_t *x);</code></td><td>Converts a hex string <code>x</code> to an <code>int*</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_oct(mpc_val_t *x);</code></td><td>Converts a oct string <code>x</code> to an <code>int*</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_float(mpc_val_t *x);</code></td><td>Converts a string <code>x</code> to a <code>float*</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_escape(mpc_val_t *x);</code></td><td>Converts a string <code>x</code> to an escaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_escape_regex(mpc_val_t *x);</code></td><td>Converts a regex <code>x</code> to an escaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_escape_string_raw(mpc_val_t *x);</code></td><td>Converts a raw string <code>x</code> to an escaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_escape_char_raw(mpc_val_t *x);</code></td><td>Converts a raw character <code>x</code> to an escaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_unescape(mpc_val_t *x);</code></td><td>Converts a string <code>x</code> to an unescaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_unescape_regex(mpc_val_t *x);</code></td><td>Converts a regex <code>x</code> to an unescaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_unescape_string_raw(mpc_val_t *x);</code></td><td>Converts a raw string <code>x</code> to an unescaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_unescape_char_raw(mpc_val_t *x);</code></td><td>Converts a raw character <code>x</code> to an unescaped version</td></tr>
  <tr><td><code>mpc_val_t *mpcf_strtriml(mpc_val_t *x);</code></td><td>Trims whitespace from the left of string <code>x</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_strtrimr(mpc_val_t *x);</code></td><td>Trims whitespace from the right of string <code>x</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_strtrim(mpc_val_t *x);</code></td><td>Trims whitespace from either side of string <code>x</code></td></tr>
</table>
<h2 id="fold-functions">Fold Functions</h2>
<table>
  <tr><td><code>mpc_val_t *mpcf_null(int n, mpc_val_t** xs);</code></td><td>Returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_fst(int n, mpc_val_t** xs);</code></td><td>Returns first element of <code>xs</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_snd(int n, mpc_val_t** xs);</code></td><td>Returns second element of <code>xs</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_trd(int n, mpc_val_t** xs);</code></td><td>Returns third element of <code>xs</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_fst_free(int n, mpc_val_t** xs);</code></td><td>Returns first element of <code>xs</code> and calls <code>free</code> on others</td></tr>
  <tr><td><code>mpc_val_t *mpcf_snd_free(int n, mpc_val_t** xs);</code></td><td>Returns second element of <code>xs</code> and calls <code>free</code> on others</td></tr>
  <tr><td><code>mpc_val_t *mpcf_trd_free(int n, mpc_val_t** xs);</code></td><td>Returns third element of <code>xs</code> and calls <code>free</code> on others</td></tr>
  <tr><td><code>mpc_val_t *mpcf_all_free(int n, mpc_val_t** xs);</code></td><td>Calls <code>free</code> on all elements of <code>xs</code> and returns <code>NULL</code></td></tr>
  <tr><td><code>mpc_val_t *mpcf_strfold(int n, mpc_val_t** xs);</code></td><td>Concatenates all <code>xs</code> together as strings and returns result </td></tr>
</table>
<h1 id="案例研究-数学语言">案例研究 - 数学语言</h1>
<h2 id="组合子方法-2">组合子方法</h2>
<p>Passing around all these function pointers might seem clumsy, but having parsers be type-generic is important as it lets users define their own output types for parsers. For example we could design our own syntax tree type to use. We can also use this method to do some specific house-keeping or data processing in the parsing phase.</p>
<p>As an example of this power, we can specify a simple maths grammar, that outputs <code>int *</code>, and computes the result of the expression as it goes along.</p>
<p>We start with a fold function that will fold two <code>int *</code> into a new <code>int *</code> based on some <code>char *</code> operator.</p>
<pre><code class="language-c">mpc_val_t *fold_maths(int n, mpc_val_t **xs) {

  int **vs = (int**)xs;

  if (strcmp(xs[1], &quot;*&quot;) == 0) { *vs[0] *= *vs[2]; }
  if (strcmp(xs[1], &quot;/&quot;) == 0) { *vs[0] /= *vs[2]; }
  if (strcmp(xs[1], &quot;%&quot;) == 0) { *vs[0] %= *vs[2]; }
  if (strcmp(xs[1], &quot;+&quot;) == 0) { *vs[0] += *vs[2]; }
  if (strcmp(xs[1], &quot;-&quot;) == 0) { *vs[0] -= *vs[2]; }

  free(xs[1]); free(xs[2]);

  return xs[0];
}
</code></pre>
<p>And then we use this to specify a basic grammar, which folds together any results.</p>
<pre><code class="language-c">mpc_parser_t *Expr   = mpc_new(&quot;expr&quot;);
mpc_parser_t *Factor = mpc_new(&quot;factor&quot;);
mpc_parser_t *Term   = mpc_new(&quot;term&quot;);
mpc_parser_t *Maths  = mpc_new(&quot;maths&quot;);

mpc_define(Expr, mpc_or(2,
  mpc_and(3, fold_maths,
    Factor, mpc_oneof(&quot;+-&quot;), Factor,
    free, free),
  Factor
));

mpc_define(Factor, mpc_or(2,
  mpc_and(3, fold_maths,
    Term, mpc_oneof(&quot;*/&quot;), Term,
    free, free),
  Term
));

mpc_define(Term, mpc_or(2, mpc_int(), mpc_parens(Expr, free)));
mpc_define(Maths, mpc_whole(Expr, free));

/* Do Some Parsing... */

mpc_delete(Maths);
</code></pre>
<p>If we supply this function with something like <code>(4*2)+5</code>, we can expect it to output <code>13</code>.</p>
<h2 id="语言方法">语言方法</h2>
<p>It is possible to avoid passing in and around all those function pointers, if you don't care what type is output by <em>mpc</em>. For this, a generic Abstract Syntax Tree type <code>mpc_ast_t</code> is included in <em>mpc</em>. The combinator functions which act on this don't need information on how to destruct or fold instances of the result as they know it will be a <code>mpc_ast_t</code>. So there are a number of combinator functions which work specifically (and only) on parsers that return this type. They reside under <code>mpca_*</code>.</p>
<p>Doing things via this method means that all the data processing must take place after the parsing. In many instances this is not an issue, or even preferable.</p>
<p>It also allows for one more trick. As all the fold and destructor functions are implicit, the user can simply specify the grammar of the language in some nice way and the system can try to build a parser for the AST type from this alone. For this there are a few functions supplied which take in a string, and output a parser. The format for these grammars is simple and familiar to those who have used parser generators before. It looks something like this.</p>
<pre><code>number &quot;number&quot; : /[0-9]+/ ;
expression      : &lt;product&gt; (('+' | '-') &lt;product&gt;)* ;
product         : &lt;value&gt;   (('*' | '/')   &lt;value&gt;)* ;
value           : &lt;number&gt; | '(' &lt;expression&gt; ')' ;
maths           : /^/ &lt;expression&gt; /$/ ;
</code></pre>
<p>The syntax for this is defined as follows.</p>
<table class='table'>
  <tr><td><code>"ab"</code></td><td>The string <code>ab</code> is required.</td></tr>
  <tr><td><code>'a'</code></td><td>The character <code>a</code> is required.</td></tr>
  <tr><td><code>'a' 'b'</code></td><td>First <code>'a'</code> is required, then <code>'b'</code> is required..</td></tr>
  <tr><td><code>'a' | 'b'</code></td><td>Either <code>'a'</code> is required, or <code>'b'</code> is required.</td></tr>
  <tr><td><code>'a'*</code></td><td>Zero or more <code>'a'</code> are required.</td></tr>
  <tr><td><code>'a'+</code></td><td>One or more <code>'a'</code> are required.</td></tr>
  <tr><td><code>'a'?</code></td><td>Zero or one <code>'a'</code> is required.</td></tr>
  <tr><td><code>'a'{x}</code></td><td>Exactly <code>x</code> (integer) copies of <code>'a'</code> are required.</td></tr>
  <tr><td><code>&lt;abba&gt;</code></td><td>The rule called <code>abba</code> is required.</td></tr>
</table>
<p>Rules are specified by rule name, optionally followed by an <em>expected</em> string, followed by a colon <code>:</code>, followed by the definition, and ending in a semicolon <code>;</code>. Multiple rules can be specified. The <em>rule names</em> must match the names given to any parsers created by <code>mpc_new</code>, otherwise the function will crash.</p>
<p>The flags variable is a set of flags <code>MPCA_LANG_DEFAULT</code>, <code>MPCA_LANG_PREDICTIVE</code>, or <code>MPCA_LANG_WHITESPACE_SENSITIVE</code>. For specifying if the language is predictive or whitespace sensitive.</p>
<p>Like with the regular expressions, this user input is parsed by existing parts of the <em>mpc</em> library. It provides one of the more powerful features of the library.</p>
<hr>
<pre><code class="language-c">mpc_parser_t *mpca_grammar(int flags, const char *grammar, ...);
</code></pre>
<p>This takes in some single right hand side of a rule, as well as a list of any of the parsers referenced, and outputs a parser that does what is specified by the rule. The list of parsers referenced can be terminated with <code>NULL</code> to get an error instead of a crash when a parser required is not supplied.</p>
<hr>
<pre><code class="language-c">mpc_err_t *mpca_lang(int flags, const char *lang, ...);
</code></pre>
<p>This takes in a full language (zero or more rules) as well as any parsers referred to by either the right or left hand sides. Any parsers specified on the left hand side of any rule will be assigned a parser equivalent to what is specified on the right. On valid user input this returns <code>NULL</code>, while if there are any errors in the user input it will return an instance of <code>mpc_err_t</code> describing the issues. The list of parsers referenced can be terminated with <code>NULL</code> to get an error instead of a crash when a parser required is not supplied.</p>
<hr>
<pre><code class="language-c">mpc_err_t *mpca_lang_file(int flags, FILE* f, ...);
</code></pre>
<p>This reads in the contents of file <code>f</code> and inputs it into <code>mpca_lang</code>.</p>
<hr>
<pre><code class="language-c">mpc_err_t *mpca_lang_contents(int flags, const char *filename, ...);
</code></pre>
<p>This opens and reads in the contents of the file given by <code>filename</code> and passes it to <code>mpca_lang</code>.</p>
<h1 id="案例研究-分词器">案例研究 - 分词器</h1>
<p>Another common task we might be interested in doing is tokenizing some block of<br>
text (splitting the text into individual elements) and performing some function<br>
on each one of these elements as it is read. We can do this with <code>mpc</code> too.</p>
<p>First, we can build a regular expression which parses an individual token. For<br>
example if our tokens are identifiers, integers, commas, periods and colons we<br>
could build something like this <code>mpc_re(&quot;\\s*([a-zA-Z_]+|[0-9]+|,|\\.|:)&quot;)</code>.<br>
Next we can strip any whitespace, and add a callback function using <code>mpc_apply</code><br>
which gets called every time this regex is parsed successfully<br>
<code>mpc_apply(mpc_strip(mpc_re(&quot;\\s*([a-zA-Z_]+|[0-9]+|,|\\.|:)&quot;)), print_token)</code>.<br>
Finally we can surround all of this in <code>mpc_many</code> to parse it zero or more<br>
times. The final code might look something like this:</p>
<pre><code class="language-c">static mpc_val_t *print_token(mpc_val_t *x) {
  printf(&quot;Token: '%s'\n&quot;, (char*)x);
  return x;
}

int main(int argc, char **argv) {

  const char *input = &quot;  hello 4352 ,  \n foo.bar   \n\n  test:ing   &quot;;

  mpc_parser_t* Tokens = mpc_many(
    mpcf_all_free,
    mpc_apply(mpc_strip(mpc_re(&quot;\\s*([a-zA-Z_]+|[0-9]+|,|\\.|:)&quot;)), print_token));

  mpc_result_t r;
  mpc_parse(&quot;input&quot;, input, Tokens, &amp;r);

  mpc_delete(Tokens);

  return 0;
}
</code></pre>
<p>Running this program will produce an output something like this:</p>
<pre><code>Token: 'hello'
Token: '4352'
Token: ','
Token: 'foo'
Token: '.'
Token: 'bar'
Token: 'test'
Token: ':'
Token: 'ing'
</code></pre>
<p>By extending the regex we can easily extend this to parse many more types of<br>
tokens and quickly and easily build a tokenizer for whatever language we are<br>
interested in.</p>
<h1 id="错误报告">错误报告</h1>
<p><em>mpc</em> provides some automatic generation of error messages. These can be enhanced by the user, with use of <code>mpc_expect</code>, but many of the defaults should provide both useful and readable. An example of an error message might look something like this:</p>
<pre><code>&lt;test&gt;:0:3: error: expected one or more of 'a' or 'd' at 'k'
</code></pre>
<h1 id="misc">Misc</h1>
<p>Here are some other misc functions that mpc provides. These functions are susceptible to change between versions so use them with some care.</p>
<hr>
<pre><code class="language-c">void mpc_print(mpc_parser_t *p);
</code></pre>
<p>Prints out a parser in some weird format. This is generally used for debugging so don't expect to be able to understand the output right away without looking at the source code a little bit.</p>
<hr>
<pre><code class="language-c">void mpc_stats(mpc_parser_t *p);
</code></pre>
<p>Prints out some basic stats about a parser. Again used for debugging and optimisation.</p>
<hr>
<pre><code class="language-c">void mpc_optimise(mpc_parser_t *p);
</code></pre>
<p>Performs some basic optimisations on a parser to reduce it's size and increase its running speed.</p>
<h1 id="局限性-常见问题解答">局限性 &amp; 常见问题解答</h1>
<h3 id="mpc支持unicode吗">mpc支持Unicode吗?</h3>
<p><em>mpc</em> Only supports ASCII. Sorry! Writing a parser library that supports Unicode is pretty difficult. I welcome contributions!</p>
<h3 id="mpc二进制安全吗">mpc二进制安全吗?</h3>
<p>不，在字符串或文件内包含<code>NULL</code>字符可能会破坏他，请避免这种情况。</p>
<h3 id="解析器进入无限循环">解析器进入无限循环！</h3>
<p>While it is certainly possible there is an issue with <em>mpc</em>, it is probably the case that your grammar contains <em>left recursion</em>. This is something <em>mpc</em> cannot deal with. <em>Left recursion</em> is when a rule directly or indirectly references itself on the left hand side of a derivation. For example consider this left recursive grammar intended to parse an expression.</p>
<pre><code>expr : &lt;expr&gt; '+' (&lt;expr&gt; | &lt;int&gt; | &lt;string&gt;);
</code></pre>
<p>When the rule <code>expr</code> is called, it looks the first rule on the left. This happens to be the rule <code>expr</code> again. So again it looks for the first rule on the left. Which is <code>expr</code> again. And so on. To avoid left recursion this can be rewritten (for example) as the following. Note that rewriting as follows also changes the operator associativity.</p>
<pre><code>value : &lt;int&gt; | &lt;string&gt; ;
expr  : &lt;value&gt; ('+' &lt;expr&gt;)* ;
</code></pre>
<p>Avoiding left recursion can be tricky, but is easy once you get a feel for it. For more information you can look on <a href="http://en.wikipedia.org/wiki/Left_recursion">wikipedia</a> which covers some common techniques and more examples. Possibly in the future <em>mpc</em> will support functionality to warn the user or re-write grammars which contain left recursion, but it wont for now.</p>
<h3 id="回溯不起作用">回溯不起作用</h3>
<p><em>mpc</em> supports backtracking, but it may not work as you expect. It isn't a silver bullet, and you still must structure your grammar to be unambiguous. To demonstrate this behaviour examine the following erroneous grammar, intended to parse either a C style identifier, or a C style function call.</p>
<pre><code>factor : &lt;ident&gt;
       | &lt;ident&gt; '('  &lt;expr&gt;? (',' &lt;expr&gt;)* ')' ;
</code></pre>
<p>This grammar will never correctly parse a function call because it will always first succeed parsing the initial identifier and return a factor. At this point it will encounter the parenthesis of the function call, give up, and throw an error. Even if it were to try and parse a factor again on this failure it would never reach the correct function call option because it always tries the other options first, and always succeeds with the identifier.</p>
<p>The solution to this is to always structure grammars with the most specific clause first, and more general clauses afterwards. This is the natural technique used for avoiding left-recursive grammars and unambiguity, so is a good habit to get into anyway.</p>
<p>Now the parser will try to match a function first, and if this fails backtrack and try to match just an identifier.</p>
<pre><code>factor : &lt;ident&gt; '('  &lt;expr&gt;? (',' &lt;expr&gt;)* ')'
       | &lt;ident&gt; ;
</code></pre>
<p>An alternative, and better option is to remove the ambiguity completely by factoring out the first identifier. This is better because it removes any need for backtracking at all! Now the grammar is predictive!</p>
<pre><code>factor : &lt;ident&gt; ('('  &lt;expr&gt;? (',' &lt;expr&gt;)* ')')? ;
</code></pre>
<h3 id="如何避免最大字符串字面长度">如何避免最大字符串字面长度。</h3>
<p>Some compilers limit the maximum length of string literals. If you have a huge language string in the source file to be passed into <code>mpca_lang</code> you might encounter this. The ANSI standard says that 509 is the maximum length allowed for a string literal. Most compilers support greater than this. Visual Studio supports up to 2048 characters, while gcc allocates memory dynamically and so has no real limit.</p>
<p>There are a couple of ways to overcome this issue if it arises. You could instead use <code>mpca_lang_contents</code> and load the language from file or you could use a string literal for each line and let the preprocessor automatically concatenate them together, avoiding the limit. The final option is to upgrade your compiler. In C99 this limit has been increased to 4095.</p>
<h3 id="ast中的自动标签很烦人">AST中的自动标签很烦人。</h3>
<p>When parsing from a grammar, the abstract syntax tree is tagged with different tags for each primitive type it encounters. For example a regular expression will be automatically tagged as <code>regex</code>. Character literals as <code>char</code> and strings as <code>string</code>. This is to help people wondering exactly how they might need to convert the node contents.</p>
<p>If you have a rule in your grammar called <code>string</code>, <code>char</code> or <code>regex</code>, you may encounter some confusion. This is because nodes will be tagged with (for example) <code>string</code> <em>either</em> if they are a string primitive, <em>or</em> if they were parsed via your <code>string</code> rule. If you are detecting node type using something like <code>strstr</code>, in this situation it might break. One solution to this is to always check that <code>string</code> is the innermost tag to test for string primitives, or to rename your rule called <code>string</code> to something that doesn't conflict.</p>
<p>Yes it is annoying but its probably not going to change!</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算机组成原理]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-ji-zu-cheng-yuan-li/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-ji-zu-cheng-yuan-li/">
        </link>
        <updated>2021-01-11T14:39:31.000Z</updated>
        <content type="html"><![CDATA[<h1 id="计算机组成原理">计算机组成原理</h1>
<p>CPU 的组成部分：</p>
<pre><code>算数逻辑单元 ALU ，负责执行算数和逻辑的运算，对应着&quot;冯.诺依曼 结构&quot;的运算器
控制器，负责发送电信号和译码（即解码指令，以便让 ALU 认识并执行），对应着&quot;冯.诺依曼 结构&quot;的控制器
寄存器，一些集成在 CPU 中的访问速度极快的存储单元，算是&quot;冯.诺依曼 结构&quot;存储器的一小部分
</code></pre>
<p>CPU 指令集可分为复杂指令集 cisc （指令复杂，参数多，不是原子指令，类似“指令糖”）和精简指令集 risc （指令简洁，原子操作）两种思路。</p>
<p>CPU 执行一条指令的步骤如下：</p>
<pre><code>取指 fetch ，从寄存器中获取指令
译码 decode ，交给控制器来译码
执行 excute，将译码结构交给 ALU 来执行
回写 write-back ，将计算结果填写回寄存器
</code></pre>
<p>现代计算机的存储结构基本是：<code>CPU —&gt; SRAM —&gt; DRAM —&gt; Disk</code> 。越往后访问速度越慢，但价格越便宜、容量越大。</p>
<p>一个硬盘有多张盘片叠成，不同盘片有编号<br>
每张盘片上的存储颗粒成环形一圈圈地排布，每一圈称为磁道，有编号<br>
每条磁道上都有一圈存储颗粒，每512*8（512字节，0.5KB）个存储颗粒作为一个扇区，扇区是硬盘上存储的最小物理单位<br>
N个扇区可以组成簇，N取决于不同的文件系统或是文件系统的配置，簇是此文件系统中的最小存储单位<br>
所有盘面上的同一磁道构成一个圆柱，称为柱面，柱面是系统分区的最小单位</p>
<p>MDR:memory data register</p>
<p>MAR:memory address register</p>
<p>RAM:random access memory</p>
<p>ROM:Read-Only Memory</p>
<h2 id="boot">Boot</h2>
<p>Master Boot Record,MBR with Bios,not support disk bigger than 2T.used 512byte.<br>
in (0,0,1) address<br>
柱面（Cylinder）<br>
磁头（Heads）<br>
扇区（Sector）<br>
446byte MBR,4*16DPT,and the end 2byte of 0x55AA.</p>
<p>DPT<br>
80 01 01 00 0B FE BF FC 3F 00 00 00 7E 86 BB 00</p>
<p>我们可以看到，最前面的&quot;80&quot;是一个分区的激活标志，表示系统可引导；&quot;01 01 00&quot;表示分区开始的磁头号为1，开始的扇区号为1，开始的柱面号为0；&quot;0B&quot;表示分区的系统类型是FAT32，其他比较常用的有04（FAT16）、07（NTFS）；&quot;FE BF FC&quot;表示分区结束的磁头号为254，分区结束的扇区号为63、分区结束的柱面号为764；&quot;3F 00 00 00&quot;表示首扇区的相对扇区号为63（小端序）；&quot;7E 86 BB 00&quot;表示总扇区数为12289662（小端序）。</p>
<table>
<thead>
<tr>
<th>偏移</th>
<th style="text-align:right">长度（字节）</th>
<th style="text-align:center">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td>00H</td>
<td style="text-align:right">1</td>
<td style="text-align:center">分区状态：00--&gt;非活动分区；80--&gt;活动分区；其它数值没有意义</td>
</tr>
<tr>
<td>01H</td>
<td style="text-align:right">1</td>
<td style="text-align:center">分区起始磁头号（HEAD），用到全部8位</td>
</tr>
<tr>
<td>02H</td>
<td style="text-align:right">2</td>
<td style="text-align:center">分区起始扇区号（SECTOR），占据02H的位0－5；该分区的起始磁柱号（CYLINDER），占据02H的位6－7和03H的全部8位</td>
</tr>
<tr>
<td>04H</td>
<td style="text-align:right">1</td>
<td style="text-align:center">文件系统标志位</td>
</tr>
<tr>
<td>05H</td>
<td style="text-align:right">1</td>
<td style="text-align:center">分区结束磁头号（HEAD），用到全部8位</td>
</tr>
<tr>
<td>06H</td>
<td style="text-align:right">2</td>
<td style="text-align:center">分区结束扇区号（SECTOR），占据06H的位0－5；该分区的结束磁柱号（CYLINDER），占据06H的位6－7和07H的全部8位</td>
</tr>
<tr>
<td>08H</td>
<td style="text-align:right">4</td>
<td style="text-align:center">分区起始相对扇区号</td>
</tr>
<tr>
<td>0CH</td>
<td style="text-align:right">4</td>
<td style="text-align:center">分区总的扇区数</td>
</tr>
</tbody>
</table>
<p>GUID Partition Table,GPT with UEFI</p>
<p><a href="https://www.ventoy.net/cn/index.html">Ventoy</a></p>
<p>Grub</p>
<p>Bios</p>
<p>UEFI</p>
<p>Hard Disk Drive,HDD</p>
<p>Solid-state drive/disk,SSD</p>
<h2 id="reference">reference:</h2>
<p><a href="https://github.com/wangfupeng1988/read-notes/blob/master/video/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90.md">计算机组成</a></p>
<p><a href="https://www.cnblogs.com/bellkosmos/p/detail_of_linux_file_system.html">Linux文件系统详解</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2013/02/booting.html">计算机是如何启动的？</a></p>
<p><a href="https://write.as/e9bzn8lgxn6pzf1t.md">Memory</a></p>
<p><a href="https://write.as/gfsikegb597lh01g.md">Boot</a></p>
<p><a href="https://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1">每个程序员都应该了解的内存知识</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[scheme/lisp资料]]></title>
        <id>https://Xiqiu-li.github.io/post/schemelisp-zi-liao/</id>
        <link href="https://Xiqiu-li.github.io/post/schemelisp-zi-liao/">
        </link>
        <updated>2021-01-08T16:27:40.000Z</updated>
        <content type="html"><![CDATA[<h2 id="课程">课程</h2>
<p>计算机领域鼎鼎大名的《计算机程序的构造和解释》（SCIP）一书早期版本为使用scheme作为教学语言<br>
北大裘宗燕老师的<a href="https://www.math.pku.edu.cn/teachers/qiuzy/progtech/">程序设计技术和方法</a>课程使用了此书作为教材，课程主页包含课程幻灯片和scheme的相关手册。</p>
<p>哈尔滨工业大学《数据结构与算法分析》<a href="https://github.com/DeathKing/Hit-DataStructure-On-Scheme">笔记</a></p>
<h2 id="书单">书单</h2>
<p>Teach Yourself Scheme in Fixnum Days<a href="http://songjinghe.github.io/TYS-zh-translation/">翻译</a><br>
<a href="http://buildyourownlisp.com/">Build Your Own Lisp</a><a href="https://ksco.gitbooks.io/build-your-own-lisp/content/">翻译</a><br>
<a href="https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours">https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours</a><br>
<a href="https://www.kancloud.cn/kancloud/yast-cn">Yet Another Scheme 入门教程</a></p>
<h2 id="手册">手册</h2>
<p><a href="https://www.cnblogs.com/lsgxeva/p/9432975.html">算法语言Scheme修订6报告 R6RS简体中文翻译</a></p>
<h2 id="文章">文章</h2>
<p><a href="http://www.yinwang.org/blog-cn/2013/03/08/on-syntax">谈语法</a><br>
<a href="http://www.yinwang.org/blog-cn/2013/04/17/languages">关于语言的思考</a><br>
<a href="http://www.yinwang.org/blog-cn/2012/08/01/interpreter">怎样写一个解释器</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[编译原理]]></title>
        <id>https://Xiqiu-li.github.io/post/bian-yi-yuan-li/</id>
        <link href="https://Xiqiu-li.github.io/post/bian-yi-yuan-li/">
        </link>
        <updated>2021-01-08T08:35:29.000Z</updated>
        <content type="html"><![CDATA[<h2 id="参见">参见:</h2>
<p><a href="http://buildyourownlisp.com/">Build Your Own Lisp</a><a href="https://ksco.gitbooks.io/build-your-own-lisp/content/">翻译</a><br>
此书使用了C语言设计lisp的编译器。以此作为C语言入门，学习C语言的同时认识程序语言的实现。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[摘录]]></title>
        <id>https://Xiqiu-li.github.io/post/zhai-lu/</id>
        <link href="https://Xiqiu-li.github.io/post/zhai-lu/">
        </link>
        <updated>2021-01-07T15:33:28.000Z</updated>
        <content type="html"><![CDATA[<p>语言！灵魂的血液。阁下，我们的思想流淌其内，成长其上。 ——Oliver Wendell Holmes, The Autocrat of the Breakfast-Table, 1858</p>
<p>如果你不能将问题分析简化，那代表你并未真正透彻了解问题。</p>
<p>It is also a sort of deity, or attribute of God as nous or &quot;mind&quot; as expressed in the following translationsJohn Everard translation:<br>
Then said I, &quot;Who art Thou?&quot; &quot;I am,&quot; quoth he, &quot;Poemander, the mind of the Great Lord, the most Mighty and absolute Emperor: I know what thou wouldest have, and I am always present with thee.&quot;G. R. S. Mead translation: And I do say: Who art thou? He saith: I am Man-Shepherd [Ποιμνδρη], Mind of all-masterhood; I know what thou desirest and I'm with thee everywhere.Salaman, Van Oyen and Wharton translation:<br>
&quot;Who are you?&quot; said I. He said, &quot;I am Poimandres the Nous of the Supreme. I know what you wish and I am with you everywhere.&quot;</p>
<p>武断的选择会妨碍普遍性<br>
Arbitrary decisions hinder generality<br>
数学法则只要与现实有关，都是不确定的；若是确定的，都与现实无关<br>
So far as the theories of mathematics are about reality,they are not certain;so far as they are certain,they are not about reality.</p>
]]></content>
    </entry>
</feed>