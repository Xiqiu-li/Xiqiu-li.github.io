<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://Xiqiu-li.github.io</id>
    <title>Xiqiu&apos;s blog</title>
    <updated>2021-01-14T01:54:27.566Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://Xiqiu-li.github.io"/>
    <link rel="self" href="https://Xiqiu-li.github.io/atom.xml"/>
    <logo>https://Xiqiu-li.github.io/images/avatar.png</logo>
    <icon>https://Xiqiu-li.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Xiqiu&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[计算的极限（五）：有限的障壁]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-wu-you-xian-de-zhang-bi/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-wu-you-xian-de-zhang-bi/">
        </link>
        <updated>2021-01-13T17:32:20.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>计算无处不在。</p>
<p>走进一个机房，在服务器排成的一道道墙之间，听着风扇的鼓噪，似乎能嗅出0和1在CPU和内存之间不间断的流动。从算筹算盘，到今天的计算机，我们用作计算的工具终于开始量到质的飞跃。计算机能做的事情越来越多，甚至超越了它们的制造者。上个世纪末，深蓝凭借前所未有的搜索和判断棋局的能力，成为第一台战胜人类国际象棋世界冠军的计算机，但它的胜利仍然仰仗于人类大师赋予的丰富国际象棋知识；而仅仅十余年后，Watson却已经能凭借自己的算法，先“理解”问题，然后有的放矢地在海量的数据库中寻找关联的答案。长此以往，工具将必在更多的方面超越它的制造者。而这一切，都来源于越来越精巧的计算。</p>
<p>计算似乎无所不能，宛如新的上帝。但即使是这位“上帝”，也逃不脱逻辑设定的界限。</p>
<p>第一位发现这一点的，便是图灵。</p>
</blockquote>
<p>《<a href="https://songshuhui.net/archives/tag/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90" target="_blank">计算的极限</a>》系列</p>
<h1>难料的世事</h1>
<p>美国普林斯顿大学，1936年9月底。</p>
<p>离乡别井，总是一种冒险。即使是一衣带水的英国与美国，文化与传统上的微妙差异，不知制造了多少惶惑。而图灵这时来到普林斯顿，可以说是双重冒险。他刚申请了普林斯顿的奖学金，但却受不了漫长的等待：精英荟萃的普林斯顿实在太诱人了。虽然图灵当时已是剑桥国王学院的研究员，每年有一笔比上不足比下有余的薪金，但人在他乡，经济上需要更多余裕。多申请一笔普林斯顿的奖学金，自然也合乎常理。</p>
<figure data-type="image" tabindex="1"><img src="https://Xiqiu-li.github.io/post-images/1610588512142.jpg" alt="" loading="lazy"></figure>
<p>（普利斯顿大学当年数学系所在的范氏大楼，图片来自http://web.math.princeton.edu/conference/frggeometry2011/）</p>
<p>但图灵没有拿到这笔奖学金。</p>
<p>在现在看来，这是件不可思议的事：即使是可计算性理论的奠基人，在这笔奖学金上竟然都得不到普林斯顿的青睐。但从当时的情况来看，图灵的遭遇又很合情合理。当时他只是一名小研究员，在学术上名气不大，论文也不多。即使关于图灵机的论文是可计算性理论的奠基石，但脱胎于逻辑的这个领域仍需时间洗练。没有人能参透未来，所以普林斯顿只能从现实角度考虑，而这个考虑的结果，就是拒绝图灵的申请。</p>
<p>但即使没有奖学金，普林斯顿对图灵来说，依然有着相当的吸引力。当时普林斯顿大学数学系与高等研究院共用一幢大楼，可谓人才济济。单在数理逻辑，丘奇自不用提，丘奇的学生克林（Kleene）和罗瑟（Rosser）也是一等一的好手，就连前文反复提到的哥德尔，在一年前访问过普林斯顿，而且计划再次访问。当时在普林斯顿的学者常常开这样的玩笑：如果希望瞻仰数学界的某位领头羊，只要呆在普林斯顿就好，他们总会过来的。人才与人才是相互吸引的，图灵选择冒险，自然有他的理由。</p>
<p>可惜人算不如天算。克林与罗瑟刚刚拿到博士学位，在外校取得了一席教职，已经离开了普林斯顿。哥德尔下一次访问要等到1939年。当时普林斯顿在可计算性理论上能拿得出手的，大概就只有丘奇。丘奇的λ演算在日后同样枝繁叶茂，但那将是本系列的另一个故事。</p>
<p>然而，丘奇的研究方式与图灵格格不入，他追求一切概念的严谨与形式化，甚至到达了难以容忍任何模糊描述的地步。从丘奇和图灵各自提出的可计算性的模型，也能看出二人研究风格的差异。丘奇的λ演算从模型本身的描述开始就充满了一种严谨精确、不可更改的气度，如同数学王国中又一块晶莹璀璨的宝石，可望而不可即；而图灵的图灵机则更为灵动直观，似乎在机械工房中就能找到它的身影，每个人都能明白它的原理。</p>
<p>可以想象这两种迥异的研究风格相遇时必然产生的矛盾。当年二人如何合作研究，在今天剩下的文件中只能窥见一鳞半爪，细节已然遗失于历史的尘埃之中。但从图灵的信件可以推测，他们一开始的合作并不顺利。尽管丘奇为人友善，尽管图灵勤勤恳恳，尽管二人都可以说是数理逻辑领域中的佼佼者，但他们首次合作并没有产生什么成果。当然，数学研究就是这样，失败才是正常情况，甚至可以说，数学研究就是在不断的失败上前进的。</p>
<p>幸而，图灵在数学上的兴趣不仅限于数理逻辑。从冯·诺依曼听来的一个有关群论的问题引起了图灵的兴趣，他很快就解决了这个问题，令冯·诺依曼对他大加青眼。也幸亏有了这个群论问题，图灵在普林斯顿的第一年不算颗粒无收。</p>
<p>但图灵最希望做的，还是有关数理逻辑的问题，他希望继续留在普林斯顿，跟随丘奇继续研究，虽然剑桥也有着强烈的吸引力。在再三的劝说后，他又申请了第二年的奖学金。这次，因为有冯·诺依曼的保荐，结果毫无悬念。</p>
<p>值得玩味的是，冯·诺依曼的信中只字未提图灵在数理逻辑方面的成就。但以后见之明看来，图灵在可计算性理论上的工作，远远比他在群论上的工作意义重大而深远。此中对比，意味深长。然而我们不能说奖学金的管理者做错了什么，只能说他们错失了一段佳话。</p>
<p>图灵在普林斯顿的生活踏入第二年。作为博士导师的丘奇，向图灵提出了一个新的题目：探求超越哥德尔不完备性定理的方法。</p>
<p>图灵再次抓住了这个机遇。</p>
<h1>一致的扩充</h1>
<p>哥德尔的不完备性定理（参见<a href="https://songshuhui.net/archives/20161" target="_blank">希尔伯特之梦，以及梦的破灭</a>以及<a href="https://songshuhui.net/archives/70194" target="_blank">计算的极限（零）</a>），其实描述的就是数学本身的界限。在此之前，数学家认为真理必可达到，而希尔伯特的那句“我们必须知道，我们必将知道”，正是这项信念奏出的最强音。但哥德尔打破了这种幻想，他证明了，对于强得足以包含算术而又不自相矛盾的数学系统而言，“真”与“可证明”是两个彻底不同的概念。在这些系统中，存在着无法证明的真理。</p>
<p>哥德尔的不完备性定理有两条。</p>
<p>第一，一个“合适的”包含了算术系统的数学系统不可能同时是一致和完备的，也就是说，如果它没有自相矛盾，那么必定存在这样的命题，它们是真的，但无法证明。</p>
<p>第二，在这样的系统中，我们可以将“系统本身没有自相矛盾”表述为系统中的一个命题，而这个命题正是一个无法被证明的真命题。假设我们有一个包含算术系统，但又没有自相矛盾的数学系统<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>，我们将表达“<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>没有自相矛盾”的命题记作<span class="MathJax_Preview">\( Cons(T) \)</span><script type="math/tex"> Cons(T) </script>，那么，哥德尔的第二不完备性定理说的就是<span class="MathJax_Preview">\( Con(T) \)</span><script type="math/tex"> Con(T) </script>在<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>中无法被证明。</p>
<p>你可能会有这样的疑问：如果把<span class="MathJax_Preview">\( Cons(T) \)</span><script type="math/tex"> Cons(T) </script>当作一条公理加进<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>中，那么得到的新系统不就能证明<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>没有自相矛盾了吗？这是否与哥德尔的定理矛盾？</p>
<p>但如果将<span class="MathJax_Preview">\( Cons(T) \)</span><script type="math/tex"> Cons(T) </script>作为新的公理，我们研究的公理系统就不再是<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>，而是另一个系统<span class="MathJax_Preview">\(T_1 = T \cup \{Cons(T)\}\)</span><script type="math/tex">T_1 = T \cup \{Cons(T)\}</script>。虽然在新的系统<span class="MathJax_Preview">\( T_1 \)</span><script type="math/tex"> T_1 </script>中的确能证明<span class="MathJax_Preview">\( Cons(T) \)</span><script type="math/tex"> Cons(T) </script>，但它只表达了原有系统<span class="MathJax_Preview">\( T \)</span><script type="math/tex"> T </script>没有自相矛盾，而对于新系统<span class="MathJax_Preview">\( T_1 \)</span><script type="math/tex"> T_1 </script>，它不能表达这一点。结合了新的公理之后，表达系统本身没有自相矛盾的命题同样会产生变化。这就像一场猫捉老鼠的游戏，我们自以为封死了一切退路，把猎物逼进了墙角，但事实却是按下葫芦浮起瓢，在我们不知道的地方又出现了新的漏洞，狡猾的猎物得以全身而退。</p>
<figure data-type="image" tabindex="2"><img src="https://Xiqiu-li.github.io/post-images/1610588630919.jpg" alt="" loading="lazy"></figure>
<p>值得一提的是，这种对公理系统的扩充方法有其独特之处：虽然新的系统比原来多了一条公理，阐述了原有体系的一致性，的确使公理系统变得更强大，但在某种意义上，这又是最保守的扩充方法。它仅仅假定了原有系统的一致性，看似没有引入什么新的知识，而得出的新系统的一致性也与原来的系统相同：如果原有系统是一致无矛盾的，阐述这一点的新公理自然不会引发矛盾；而如果原有系统本身就存在矛盾，那么它能证明一切命题，无论是真是假，那么加入新的公理也不会改变这一点。</p>
<p>这可能不是最有趣的扩充方法，但却是最稳妥的。如果随便添加公理，我们得到的更有可能得到的是一个自相矛盾的无用系统。与其矛盾，不如稳健。</p>
<p>但要用这种方法在系统内部证明自身的一致性，实际上并不可行。的确，我们可以多次重复添加公理的过程，得到从T_1、T_2开始的一系列理论系统，但它们的一致性是相同的，都依赖于起始的数学系统T，而且这一点是可以证明的。既然在起始的系统中不能证明自身的一致性，那么之后的一系列系统，无论重复多少次，都不可能证明自身的一致性。</p>
<p>那么，如果我们重复无限次，添加无限条公理呢？这样的话，无论使用了多少条公理，总有比它们更大的一条公理将会断言前面公理的一致性，一环扣一环，直至无穷，整个系统岂不是无懈可击？</p>
<h1>系统的证明</h1>
<p>从某个理论<span class="MathJax_Preview">\( T_0 = T \)</span><script type="math/tex"> T_0 = T </script>开始，逐次添加关于新理论一致性的公理<span class="MathJax_Preview">\( Cons(T_i) \)</span><script type="math/tex"> Cons(T_i) </script>，不断得到<span class="MathJax_Preview">\( T_1 = T_0 + Cons(T_0), T_2 = T_1 + Cons(T_1), T_3, \ldots \)</span><script type="math/tex"> T_1 = T_0 + Cons(T_0), T_2 = T_1 + Cons(T_1), T_3, \ldots </script>，一直到最后包含无穷条公理的<span class="MathJax_Preview">\( T_\infty \)</span><script type="math/tex"> T_\infty </script>，其中每一条公理都有更大的公理来断言它的一致性。似乎我们就得到了一个超越哥德尔不完备性定理的数学系统。</p>
<p>但事情当然不会那么顺利。</p>
<p>首先，在包含无穷条公理的数学系统中，如何在系统内部谈论它的一致性，这并非顺理成章。的确，从理论上来说，包含任意的无穷条公理的数学系统是存在的。但如果要在这种系统内思考，很快就会遇到困境。先不说在系统中进行推理，就算是阅读一个证明，也并非显然。要理解这一点，需要对“形式证明”有更具体的理解。</p>
<p>一个数学系统内的形式证明，实际上是一串有限的命题组合，其中的命题要么是系统内的公理，要么是此前命题明白无误的简单逻辑推论，而最后出现的命题就是这个形式证明要得出的结论，也就是要证明的定理。这种一环套一环的组合方式，恰好保证了最后结论的正确性。而我们在阅读一个形式证明时，也只需要顺次检查这些命题，看看每一个命题是否本身就是公理或者此前命题的推论，就能验证这个证明的正确性。</p>
<p>而如果要在系统内部用命题表达系统本身的一致性，就要用到哥德尔在证明他的不完备性定理时用到的技术。简单来说，我们需要“阅读证明”的这个过程能够完全机械化，即使将人脑换成图灵机，也可以完成类似的验证。但如果数学系统本身包含无穷条公理的话，这个机械的阅读过程可能甚至连第一步都无法开始：如果有无穷条公理，那么面对一个命题，又如何知道它是否一个公理呢？</p>
<p>打个比方，数学系统好比是座仓库，里边装的都是公理。现在有人给我们一件东西，比如说一本书，我们的任务则是查看仓库里是否有一模一样的存货。如果仓库里只有有限样东西，一个个清点总能完成任务；但如果仓库容纳了无数物件，即使仓库的确有相应的存货，如果清点的次序不当，也有可能永远也碰不上我们的目标。</p>
<figure data-type="image" tabindex="3"><img src="https://Xiqiu-li.github.io/post-images/1610588710216.jpg" alt="" loading="lazy"></figure>
<p>同样，要判断某个命题是否给定的数学系统中的公理，如果公理只有有限条，那么一个一个比较，总能在有限时间内判断出来。但对于无穷条公理的情况，这种方法有着严重的缺陷。如果检查的命题的确是公理，那么有朝一日总会停止；但反过来，如果我们检查了很久，仍然没有找到它是公理的证据的话，因为我们没有清点公理的一般方法，所以同样无法断言是否有遗漏。</p>
<p>所以一般而言，在一个包含无穷条公理的数学系统中，我们甚至无法在有限时间内机械地判断一个证明是否正确。尽管形式上仍然可以对形式证明进行定义，但我们几乎无法有效地考察这样的定义。同样，在这类系统中，有关形式证明的概念，尤其是系统本身的一致性，也如同处于矛盾中的说谎者，根本无法被表达。在这些系统中，难以谈及有关证明论的问题。</p>
<p>然而，在数学家们平常使用的数学系统中，不乏包含无穷条公理的例子。其中包括策梅洛-弗兰克公理系统，它被认为是现代数学的公认基础；还有皮亚诺算术的一阶逻辑版本，这个版本在数理逻辑的研究中经常出现。虽然这些系统同样包含无穷条公理，但数学家们在使用这些系统进行证明时没有一丝的踌躇，似乎其中形式证明的意义理所当然，与我们之前的结论背道而驰，这又是为什么呢？</p>
<p>答案很简单：这些数学系统拥有特殊的性质，虽然包括无穷条公理，却能在有限的时间内判断某个命题是否其中的公理。在数理逻辑中，这些系统被称为可有效生成的公理系统。</p>
<p>“可有效生成的公理系统”，顾名思义，这种系统里的公理都是可以“有效生成”的，也就是说，存在一台图灵机，可以“生成”所有的公理，将它们一一打印到纸带上，而打印出来的命题则必定是系统中的公理。可以说，这样的公理系统可以约化为一台图灵机。</p>
<p>回到仓库的比喻的话，一个可有效生成的数学系统同样是公理的仓库，但其中有着某种规律。比如一个包揽全世界所有书的仓库（它的别名叫图书馆），要判断某样物品是否有存货就太简单了：只要是书，那就有存货；如果不是书，那就没有。无需费力找到具体的对应，但同样可以确定仓库中是否存在相同的存货。</p>
<figure data-type="image" tabindex="4"><img src="https://Xiqiu-li.github.io/post-images/1610588735802.jpg" alt="" loading="lazy"></figure>
<p>如果一个数学系统是可有效生成的，那么可以构造一个图灵机来判断某个证明是否正确。它能仅仅承认那些系统内正确的证明，对于错误的证明则一律拒绝。那么，即使有无穷条公理，我们仍然能通过这台图灵机考察关于形式证明的性质，从而可以谈论所有有关证明论的问题，包括我们关心的系统一致性。</p>
<p>而我们希望讨论的扩充系统，也就是通过无穷次扩充得到的数学系统，的确是一个可有效生成的系统。所以，我们对它一致性的讨论是有意义的。</p>
<p>对于读者来说，可能会感觉这些围绕着无穷条公理的讨论仅仅是一种吹毛求疵。但对于数学，特别是数理逻辑而言，精确性无比重要。在日常生活中，我们使用的语言太模糊太杂乱，人们的本意常常迷失在语言当中，有时连人本身都不理解口中的言说。但在数理逻辑中，一切含糊都被符号明晰，没有歧义，没有矛盾，对就是对，错就是错。这种确定性，正是数学真理性的所在。</p>
<h1>有限的障壁</h1>
<p>无限扩充得到的公理系统<span class="MathJax_Preview">\( T_\infty \)</span><script type="math/tex"> T_\infty </script>，虽然能在其中表达系统本身的一致性，但它的一致性却不像我们想象中的那么显然。虽然对于其中的每一条新公理<span class="MathJax_Preview">\( Cons(T_k) \)</span><script type="math/tex"> Cons(T_k) </script>，都有比它更强大的另一条公理<span class="MathJax_Preview">\( Cons(T_{k+1}) \)</span><script type="math/tex"> Cons(T_{k+1}) </script>保证它的一致性，但这真的能证明包含无数条新公理的系统是一致无矛盾的吗？</p>
<p>我们重温一下一致性的定义：一个公理系统是一致无矛盾的，当且仅当系统中不存在对于假命题的证明。也就是说，无论系统有多大有多复杂，只要系统本身不能证明任意一个假命题，比如说“1=2”，那么这个系统就是一致的。</p>
<p>我们现在尝试考虑无限扩充得到的公理系统<span class="MathJax_Preview">\( T_\infty \)</span><script type="math/tex"> T_\infty </script>。要超越哥德尔不完备性定理，就需要在系统内部证明有关系统本身一致性的命题<span class="MathJax_Preview">\( Cons(T_\infty) \)</span><script type="math/tex"> Cons(T_\infty) </script>。假设系统中存在一个这样的形式证明<span class="MathJax_Preview">\( P \)</span><script type="math/tex"> P </script>，这意味着什么呢？</p>
<p>我们知道，形式证明的长度是有限的，毕竟无论是人类还是计算机，都无法完整阅读无限长的证明。所以，证明<span class="MathJax_Preview">\( P \)</span><script type="math/tex"> P </script>用到的公理也只有有限条。既然有限，那么其中形如<span class="MathJax_Preview">\( Cons(T_k) \)</span><script type="math/tex"> Cons(T_k) </script>的公理也有限，对应的<span class="MathJax_Preview">\(k\)</span><script type="math/tex">k</script>必然有一个最大值，不妨设为<span class="MathJax_Preview">\( N \)</span><script type="math/tex"> N </script>。那么，证明<span class="MathJax_Preview">\( P \)</span><script type="math/tex"> P </script>中的所有公理，在更小的系统<span class="MathJax_Preview">\( T_{N+1} \)</span><script type="math/tex"> T_{N+1} </script>中早已存在，所以证明<span class="MathJax_Preview">\( P \)</span><script type="math/tex"> P </script>在<span class="MathJax_Preview">\( T_{N+1} \)</span><script type="math/tex"> T_{N+1} </script>中同样有效。也就是说，仅仅在<span class="MathJax_Preview">\( T_{N+1} \)</span><script type="math/tex"> T_{N+1} </script>中就可以证明<span class="MathJax_Preview">\( T_{\infty} \)</span><script type="math/tex"> T_{\infty} </script>的一致性，它也蕴含了更小的系统<span class="MathJax_Preview">\( T_{N+1} \)</span><script type="math/tex"> T_{N+1} </script>的一致性。</p>
<p>也就是说，因为形式证明的长度是有限的，如果无限扩充后的系统<span class="MathJax_Preview">\( T_\infty \)</span><script type="math/tex"> T_\infty </script>能超越不完备性定理，证明它自身的一致性，那么在之前有限次扩充中，必然已经存在一个系统，它能证明自身的一致性。根据之前的论述，这也表示一开始的出发点——也就是系统<span class="MathJax_Preview">\(T\)</span><script type="math/tex">T</script>——也能证明自身的一致性，而这是不可能的。</p>
<p>尽管我们尝试用无限来突破不完备性定理，但名为“有限”的障壁挡住了我们的去路。</p>
<p><img src="https://Xiqiu-li.github.io/post-images/1610588760196.jpg" alt="" loading="lazy"><br>
（图片来自http://www.personal.psu.edu/afr3/blogs/SIOW/）</p></p>
<p>在某种意义上，我们能够处理的，只有“有限”，而无法处理真正的“无限”。那些我们![](https://Xiqiu-li.github.io/post-images/1610588760196.jpg)们能认识到的。</p>
<p>我们无法认识一切，相对地，我们永远有着等待探索的世界。</p>
<p>既然从一致性的方向无法突破，那么从另一个方向呢？哥德尔不完备性定理断言，对于合适的数学系统而言，一致性与完备性是两立的，那么，是否可以不停地扩充系统，在保证一致性的前提下，使它能证明越来越多的命题呢？最后又是否能得到一个完备的系统，在其中可以证明所有真命题呢？</p>
<p>为了回答这个问题，图灵将眼光投向了无穷的彼岸。</p>
<p>（如非特别说明，插图由Neko提供，微博号@NEKOinHeaven）</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算的极限（四）：机械计算的圭臬]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-si-ji-jie-ji-suan-de-gui-nie/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-si-ji-jie-ji-suan-de-gui-nie/">
        </link>
        <updated>2021-01-13T17:24:22.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>计算无处不在。</p>
<p>走进一个机房，在服务器排成的一道道墙之间，听着风扇的鼓噪，似乎能嗅出0和1在CPU和内存之间不间断的流动。从算筹算盘，到今天的计算机，我们用作计算的工具终于开始量到质的飞跃。计算机能做的事情越来越多，甚至超越了它们的制造者。上个世纪末，深蓝凭借前所未有的搜索和判断棋局的能力，成为第一台战胜人类国际象棋世界冠军的计算机，但它的胜利仍然仰仗于人类大师赋予的丰富国际象棋知识；而仅仅十余年后，Watson却已经能凭借自己的算法，先“理解”问题，然后有的放矢地在海量的数据库中寻找关联的答案。长此以往，工具将必在更多的方面超越它的制造者。而这一切，都来源于越来越精巧的计算。</p>
<p>计算似乎无所不能，宛如新的上帝。但即使是这位“上帝”，也逃不脱逻辑设定的界限。</p>
<p>第一位发现这一点的，便是图灵。</p>
</blockquote>
<p>《<a href="https://songshuhui.net/archives/tag/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90" target="_blank">计算的极限</a>》系列</p>
<h1>殊途同归</h1>
<p>大洋彼岸寄来的论文，对于图灵来说，并不是什么好消息。在看到丘奇的论文后，图灵有过何等反应，至今恐怕已不可考。面对着一位在数理逻辑方面已然小有名气的职业数学家，与自己一起独立发现了相同的突破性结果。往好处想，这说明图灵自己的水平已经达到了当时数理逻辑研究的前沿；往坏处想，重复了别人的结果，哪怕是独立发现的，似乎都有些不对味儿。</p>
<p>然而，在下定论之前，图灵还有一件事情要搞清楚。他和丘奇对“可计算性”的定义，分别建筑在图灵机与λ演算之上。那么，在不同的基础上定义的两种“可计算性”，是貌合神离还是本为一体？</p>
<p>图灵机与λ演算，两者似乎都在平平无奇中暗藏玄机。作为计算模型，它们有很多相似之处，比如自我指涉的能力。但它们看起来又是如此不同，图灵机是一台在工程上能建造的机器，而λ演算则是一个彻头彻尾的数学模型。看起来，要回答这个问题，并非易事。</p>
<p><img src="https://Xiqiu-li.github.io/post-images/1610558742645.jpg" alt="" loading="lazy"><br>
<img src="https://Xiqiu-li.github.io/post-images/1610558762986.png" alt="" loading="lazy"></p>
<p>图灵知道，丘奇也知道，他们已经踏入了一个新领域。昔日希尔伯特在他的二十三个问题中，一语带过的那个“机械化的运算”，即将被赋予精确的数学含义。但正因如此，踏出的第一步必须慎之又慎，尤其对于“可计算性”这个最基础的定义，必须做到毫不含糊。为此，为了消除模棱两可之处，图灵机与λ演算是否能力相当，这是个必须回答的问题。</p>
<p>知己知彼，百战不殆。为了解答这个问题，图灵开始钻研λ演算，试图弄清到底λ演算能计算什么。终于，他证明了，所有λ演算能计算的函数，他的图灵机也能计算，反之亦然。也就是说，λ演算与图灵机的计算能力是等价的，两种模型定义的“可计算性”实际上殊途同归。他将这个结果作为附录补充到了他的论文。</p>
<p>对于图灵来说，这既是个坏消息，也是个好消息。坏消息是，他的结果与丘奇的重复了，对于发表文章来说，这不是什么好事情。好消息是，他的结果与丘奇的重复了，但他对可计算性的定义与丘奇的截然不同，而且两种看似毫无关系的定义，在实质上是相同的，这说明，他们对可计算性的定义，这最初的一步踏出的方向是正确的。一个人提出的定义很可能忽视某个方面，但现在两个截然不同的定义引向相同的结果，在交叉印证下，几无出错之虞。</p>
<p>可以说，图灵的工作面世之日，正是可计算性理论呱呱坠地之时。</p>
<p>也难怪纽曼教授一开始不相信图灵的工作。仅仅二十出头，刚刚踏入科学界的年轻人，就解决了如此重要的问题，而且为一个全新的领域立下了奠基石，这种人，即使在剑桥这个英国顶尖学府，也可谓难得一见。倒不如说，一开始不相信，这才是正常的反应。</p>
<p>但即便不相信，数学证明就是证明。即使纽曼教授并不专精于数理逻辑，还是能看出图灵论文的过人之处。他决定为图灵争取发表的机会。</p>
<p>这并非易事。因为从结论上说，图灵重复了丘奇的结果，所以最初联系的几个期刊的编辑都婉拒了纽曼的要求：他们只看到了论文的结论，没看到论文的精髓。最后，纽曼找到了当时伦敦皇家学会学报的编辑，经过三催四劝，终于说服编辑发表图灵的文章。</p>
<p>《论可计算数，及其在可判定性问题上的应用》，图灵的这篇文章，后来被认为是伦敦皇家学会学报发表过的最重要的文章之一。</p>
<figure data-type="image" tabindex="1"><img src="https://Xiqiu-li.github.io/post-images/1610558806825.gif" alt="" loading="lazy"></figure>
<h1>万变之宗</h1>
<p>乘着远洋货轮，图灵的论文很快传到了大洋彼岸，在普林斯顿掀起了一阵旋风。</p>
<p>在普林斯顿高等研究院的哥德尔，与丘奇有过不少碰面的机会。他读过丘奇的论文，大概也听过丘奇本人介绍他的λ演算。但哥德尔对λ演算一直颇有微词。实际上，作为一种计算模型，λ演算从未得到他的认可。它与人们日常接触到的“计算”毫无相似之处，更像是符号的堆砌和推演。虽然其中的计算的确可以机械性地完成，但要证明这一点绝非易事。事实上，这是一个远非显然的定理，证明也相当复杂。总而言之，λ演算并不像机械的计算，更像智慧的推理。</p>
<p>实际上，哥德尔自己也有一套“机械计算”的模型，那正是他在证明哥德尔不完备性定理时发展出来的递归函数体系。这套体系将“机械计算”定义为递归函数能计算的内容，而递归函数，顾名思义，就是可以用某些递归方式定义的整数函数。但哥德尔对他自己的模型同样不满意，原因同样是他的模型似乎需要太多的聪明才智，不像一台机器。</p>
<p>但图灵的论文瞬间就令哥德尔为之折服。</p>
<p>任何人，只要看一眼图灵机的定义，都会认同图灵机的计算完全是机械演算，完全可以造出一台可以运作的实际的图灵机。而更重要的是，图灵机抓住了“机械计算”的神韵。</p>
<p>机械计算是什么？是机器可以做出的计算。但机器可以千奇百怪，要用三言两语抓住本质，似乎不太可能。那么，何不反其道而行之？与其想像这些机器共有的特性，不如寻找它们共有的限制。</p>
<p>这正是图灵在论文中的做法。他总结了以下几个机器计算的限制：</p>
<p>第一：一台机器只有有限个可以分辨的状态；一台机器能分辨的表示数据的符号只有有限种。</p>
<p>开关或开或合，电路或通或断，中间的变化是跳跃式的。即使是连续的电信号，由于不可避免的热噪声影响，通过测量能分辨出的状态同样只有有限个。虽然现代的计算机看似有无限可能，但这只是幻觉。CPU和内存中的电路，数量虽然庞大无比，但总归是有限的，它们的通断形成的不同状态亦是如此。同理，虽然符号、信号在细节上可以有无数种变化，但由于精度等问题，即使是人，也无法事无巨细将所有细节一一分辨出来，更何况机器。</p>
<figure data-type="image" tabindex="2"><img src="https://Xiqiu-li.github.io/post-images/1610558843952.jpg" alt="" loading="lazy"></figure>
<p>第二：机器的每一步操作需要的时间有一个下限，而每次操作最多只能读入与改写外部有限个符号。在某次操作读写某处的符号后，下一步机器读写的符号与之前符号的距离应该是有界的。</p>
<p>由于物理的限制，不存在速度无限的物体。无论任何机器，都不能在有限的时间内作出无限次操作，当然也不可能有无限次读入与改写。同样，读写头移动的速度是有限的，所以两次操作读写符号的距离当然也有限制。</p>
<p>第三：在某步操作中，机器的行动完全取决于它当时的内部状态以及读取到的符号。</p>
<p>机器就是机器，它应该做的，就是按照预先规划的图纸一步一步执行。没有异想天开，没有灵光一现，只有照章办事，只有步步为营。</p>
<figure data-type="image" tabindex="3"><img src="https://Xiqiu-li.github.io/post-images/1610558868467.jpg" alt="" loading="lazy"></figure>
<p>这几个限制看起来相当合理，甚至显得理所当然。但就从如此平平无奇的限制出发，图灵用缜密的逻辑说明了，一台服从这些限制的机器能计算的问题，必定可以用一台特定的图灵机解决。也就是说，任何一台服从这些限制的机器，无论设计如何精巧，构成如何复杂，它的计算能力都不可能超越图灵机，无一例外。</p>
<p>我们甚至可以说，图灵机的设计本身，正是这些限制的一种体现。图灵很可能一开始就意识到了这些限制，再由此出发，去定义他的图灵机。哥德尔之所以对图灵机击节叹赏，大概也正因蕴含在它定义中的，图灵对“机械计算”的深刻洞察。相比之下，虽然与之等价的λ演算也尚算精致，但对于“机械计算”只得其形未得其神，显然逊色不少。</p>
<p>现在，希尔伯特在他的问题中那模糊的“机械计算”，终于有了一个精确的定义：机械计算，就是图灵机能做的计算。这又被称为图灵-丘奇论题，正是可计算性理论的奠基石。</p>
<p>除了λ演算与递归函数以外，还有许多计算系统与图灵机等价。波斯特对应问题，计数器机，马尔可夫算法，甚至元胞自动机，这些计算模型都与图灵机等价。但以我们的后见之明来看，图灵机仍然是机械计算最自然最有用的模型之一。</p>
<figure data-type="image" tabindex="4"><img src="https://Xiqiu-li.github.io/post-images/1610558896378.gif" alt="" loading="lazy"></figure>
<p>也正因这篇论文，图灵得到了到普林斯顿读博深造的机会，在丘奇的指导下，得以继续探索可计算性的无限可能。在大洋彼岸等待图灵的，又是可计算性理论的一篇新章。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算的极限（三）：函数构成的世界]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-san-han-shu-gou-cheng-de-shi-jie/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-san-han-shu-gou-cheng-de-shi-jie/">
        </link>
        <updated>2021-01-13T17:22:59.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>计算无处不在。</p>
<p>走进一个机房，在服务器排成的一道道墙之间，听着风扇的鼓噪，似乎能嗅出0和1在CPU和内存之间不间断的流动。从算筹算盘，到今天的计算机，我们用作计算的工具终于开始量到质的飞跃。计算机能做的事情越来越多，甚至超越了它们的制造者。上个世纪末，深蓝凭借前所未有的搜索和判断棋局的能力，成为第一台战胜人类国际象棋世界冠军的计算机，但它的胜利仍然仰仗于人类大师赋予的丰富国际象棋知识；而仅仅十余年后，Watson却已经能凭借自己的算法，先“理解”问题，然后有的放矢地在海量的数据库中寻找关联的答案。长此以往，工具将必在更多的方面超越它的制造者。而这一切，都来源于越来越精巧的计算。</p>
<p>计算似乎无所不能，宛如新的上帝。但即使是这位“上帝”，也逃不脱逻辑设定的界限。</p>
<p>第一位发现这一点的，便是图灵。</p>
</blockquote>
<p>《<a href="https://songshuhui.net/archives/tag/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90" target="_blank">计算的极限</a>》系列</p>
<h1>函数构成的世界</h1>
<figure data-type="image" tabindex="1"><img src="https://Xiqiu-li.github.io/post-images/1610558301060.jpg" alt="" loading="lazy"></figure>
<p style="text-align: center">【图片来自Wikipedia】</p>
<p>丘奇作为图灵在数学上的前辈，思考的问题自然比图灵要深远得多。图灵考虑的问题，仅仅是希尔伯特的可判定性问题，而丘奇当时思考的，是如何重构数学的基础。</p>
<p>当时正是第三次数学危机勃发之际，数学界各路人马对数学基础应该置于何处争论不休。当时公理化集合论刚刚建立，作为新事物，自然有人持观望态度，而丘奇就是其中一位，他觉得自己可以创造一个更好的理论，以此作为数学的基础。与其选择集合与包含这两个概念，他选择了数学中另一个重要的概念：函数。</p>
<p>数学家眼中的函数，比你想像的要广泛得多。在中学数学中，说到函数，自然会联想起它在平面直角坐标系的图像。这是因为中学数学中的函数，大部分情况下不过是从实数到实数的映射而已。而数学家眼中的函数，可能与程序员眼中的函数更相似：它们更像是一个黑箱，从一边扔进去某个东西，另一边就会吐出来另一个东西。</p>
<figure data-type="image" tabindex="2"><img src="https://Xiqiu-li.github.io/post-images/1610558328316.jpg" alt="" loading="lazy"></figure>
<p style="text-align: center">【感谢neko（@iNEKO_mini）提供图片】</p>
<p>我们并没有限定能扔进黑箱的东西。事实上，将黑箱本身扔进黑箱也是可以的。对这种把戏，数学家们再熟悉不过了，在泛函分析这一数学分支中，数学家们就经常研究一种叫“算子”的数学概念，在某些特殊情况下，就是那些将一个函数变成另一个函数的函数。所以，不去限定能扔进黑箱的东西，似乎也没什么问题。</p>
<figure data-type="image" tabindex="3"><img src="https://Xiqiu-li.github.io/post-images/1610558353968.jpg" alt="" loading="lazy"></figure>
<p style="text-align: center">【再次感谢neko（@iNEKO_mini）提供图片】</p>
<p>总而言之，函数就是将一个函数变成另一个函数的东西。那么，要用符号表达这么普遍的函数概念，我们需要什么呢？</p>
<p>首先，就像在方程中我们用x, y, z等等符号表示未知数，我们也希望能用符号表示未知函数。我们将这些表示未知函数的符号称为变量。</p>
<p>其次，如果我们手上有两个函数<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>和<span class="MathJax_Preview">\( N \)</span><script type="math/tex"> N </script>，那么我们自然希望研究函数<span class="MathJax_Preview">\( N \)</span><script type="math/tex"> N </script>被函数<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>“处理”之后会变成什么。也就是说，既然<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>是一个函数，能将一个函数变成另一个函数，那么<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>会将<span class="MathJax_Preview">\( N \)</span><script type="math/tex"> N </script>这个函数变成什么呢？即使不知道具体的过程，我们也希望能表达最后的结果。所以，我们将<span class="MathJax_Preview">\( N \)</span><script type="math/tex"> N </script>被<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>处理后得到的结果记为<span class="MathJax_Preview">\( (M \, N) \)</span><script type="math/tex"> (M \, N) </script>。这被称为函数的应用（application）。</p>
<p>最后，也是最抽象的概念，就是函数的抽象（abstraction）。</p>
<p>我们可以用变量x来表示未知的函数，自然也可以用x来构造更多的函数。比如<span class="MathJax_Preview">\( (x \, x) \)</span><script type="math/tex"> (x \, x) </script>就表示函数x应用到自己身上的结果，而<span class="MathJax_Preview">\( ((x \, x) \, y) \)</span><script type="math/tex"> ((x \, x) \, y) </script>就表示将刚才得到的结果应用到另一个未知函数y上得到的结果，如此等等，不一而足。如果我们将变量x替换成一个具体的函数f，那么这些包含变量x的表达式就会变成包含具体函数f的表达式。</p>
<p>也就是说，如果我们有一个包含变量x的表达式<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>，对于任意一个函数f，我们可以将它对应到一个新的表达式，记作<span class="MathJax_Preview">\( M(f) \)</span><script type="math/tex"> M(f) </script>，而这个新的表达式是将M中的所有x替换成f所得到的。比如说，如果<span class="MathJax_Preview">\( M=(x \, x) \)</span><script type="math/tex"> M=(x \, x) </script>，那么<span class="MathJax_Preview">\( M(f)=(f \, f) \)</span><script type="math/tex"> M(f)=(f \, f) </script>，<span class="MathJax_Preview">\( M((y \, y))=((y \, y) (y \, y)) \)</span><script type="math/tex"> M((y \, y))=((y \, y) (y \, y)) </script>，等等。</p>
<p>一个表达式也是一个函数。我们从表达式M出发，可以得到把一个函数f对应到另一个函数<span class="MathJax_Preview">\( M(f) \)</span><script type="math/tex"> M(f) </script>的方法，而这正是一个函数。也就是说，我们能从一个表达式“抽象”出一个函数。我们将这个函数记作<span class="MathJax_Preview">\( \lambda x. \, M \)</span><script type="math/tex"> \lambda x. \, M </script>，x是我们所要考虑的自由变量。</p>
<p>【注：在这里，我们只能替换那些所谓的“自由变量”。粗略地说，自由变量是那些之前没有被抽象过的变量。详细的技术细节略显繁复，而且也有办法绕过，所以于此略过。】</p>
<p>从这三点基本要求出发，丘奇开始定义他的λ演算。他将他考虑的这些函数称为“λ项”，而所有的λ项都可以从以下三种途径构造而成：</p>
<p>1. （变量）所有变量<span class="MathJax_Preview">\( x,\, y,\, z,\, \ldots \)</span><script type="math/tex"> x,\, y,\, z,\, \ldots </script>都是λ项。<br/>
1. （应用）如果<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>和<span class="MathJax_Preview">\( N \)</span><script type="math/tex"> N </script>都是λ项，那么<span class="MathJax_Preview">\( (M \, N) \)</span><script type="math/tex"> (M \, N) </script>也是λ项。<br/>
2. （抽象）如果<span class="MathJax_Preview">\( M \)</span><script type="math/tex"> M </script>是一个λ项而x是一个变元，那么<span class="MathJax_Preview">\( \lambda x. \, M \)</span><script type="math/tex"> \lambda x. \, M </script>也是一个λ项。</p>
<p>接下来，丘奇定义了一些λ项之间的转换法则。</p>
<p>首先是<span class="MathJax_Preview">\( \alpha \)</span><script type="math/tex"> \alpha </script>重命名，这项转换可以使我们在遵循一定的规则下，任意变换λ项中的变量名称，而不改变λ项本身的意义。也就是说，λ项中变量的名称无关紧要，无论是x, y, z还是苹果、香蕉、榴莲，又或者是小庄、游游、李清晨，项的本质是不变的。</p>
<p>然后是最重要的<span class="MathJax_Preview">\( \beta \)</span><script type="math/tex"> \beta </script>规约：</p>
<p><span class="MathJax_Preview">\( (\lambda x. \, M) \, f \; \rightarrow_{\beta} \; M[x \leftarrow f] \)</span><script type="math/tex"> (\lambda x. \, M) \, f \; \rightarrow_{\beta} \; M[x \leftarrow f] </script></p>
<p>在这里，<span class="MathJax_Preview">\( M[x \leftarrow f] \)</span><script type="math/tex"> M[x \leftarrow f] </script>实际上是<span class="MathJax_Preview">\( M(f) \)</span><script type="math/tex"> M(f) </script>的严谨记法，表明了我们要替换的变量。而<span class="MathJax_Preview">\( \beta \)</span><script type="math/tex"> \beta </script>规约实际上就是根据定义计算函数的一个过程。</p>
<p>最后，还有一个<span class="MathJax_Preview">\( \eta \)</span><script type="math/tex"> \eta </script>变换。它的实质是所谓的外延性，也就是说，如果两个项对所有函数的作用都是相同的话，那么就认为这两个项是相同的。</p>
<p>这么几条简单的法则，就是丘奇的λ演算的全部内容。</p>
<p>那么简单的法则，很难想象λ演算能表达什么复杂的数学概念，这看起来不过是符号的简单推演而已。但既然同样简单的图灵机中也暗藏玄机，那说不定λ演算也有它自己的复杂内涵。</p>
<figure data-type="image" tabindex="4"><img src="https://Xiqiu-li.github.io/post-images/1610558381117.jpg" alt="" loading="lazy"></figure>
<p style="text-align: center">【图片来自http://blogs.msdn.com/b/ashleyf】</p>
<h1>分崩离析的世界</h1>
<p>丘奇最初建立λ演算的目的，是希望将它作为一种逻辑推理的方法。我们可以将某些逻辑公理表达为λ项；对于某个逻辑命题，我们可以先将其转化为λ项，再根据λ演算的法则将它不断简化，而命题正确与否就蕴含在计算结果之中。</p>
<p>通过这种方法，丘奇成功地在λ演算的框架下表达了不少的数学系统。λ演算看起来是如此的成功，甚至达到了无所不能的程度。</p>
<p>但如果我们还记得<a href="https://songshuhui.net/archives/20161" title="希尔伯特之梦，以及梦的破灭" target="_blank">哥德尔的教训</a>的话，无所不能有时并不一定是什么好事，因为在数学和逻辑的领域中，对于有意义的逻辑系统，强大的表达能力必然伴随着坚不可摧的限制。如果一个系统无所不能，那么更大的可能是它本身就自相矛盾。就像一个理论，如果对的也好错的也罢，正面反面都能解释得通，那相当于完全没有解释。</p>
<p>果然，几乎在丘奇向学术界展示他的λ演算的同时，克林（Kleene）和科里（Curry）就证明了，作为一个逻辑推理系统，λ演算在本质上就存在着矛盾，它是不一致的。通过适当地构造一些λ项，克林和罗瑟（Rosser）成功地利用λ演算找到了一切命题的证明，甚至包括那些错误的命题！一个连错误的命题都能证明的逻辑系统，也就是说一个不一致的逻辑系统，没有任何意义。</p>
<p>值得一提的是，上面这几位后来都成为了数理逻辑界的大人物。克林和罗瑟是丘奇的学生，而科里则师从希尔伯特。我们后面还会讲到这位科里教授，他的事迹之一就是有整整三个不同的编程语言是以他的名字命名的，连中间名都用上了，影响力可见一斑。</p>
<p>事实上，丘奇当初在筑建λ演算之时，就已模糊地认识到了这个问题，但他觉得这只是一种幻象，通过某些适当的限制，就能摆脱这些恼人的问题。但丘奇错了，实际上这是一个本质性的问题。</p>
<p>那么，问题的根源在何处？</p>
<p>我想，读过本系列之前文章的读者应该都猜到了，又是那绕不过去的自我指涉！</p>
<div id="attachment_20174" style="width: 426px" class="wp-caption aligncenter">
<figure data-type="image" tabindex="5"><img src="https://Xiqiu-li.github.io/post-images/1610558474116.jpg" alt="" loading="lazy"></figure>
<p class="wp-caption-text">自指</p></div>
<p>但是，自我指涉在什么地方呢？</p>
<p>还记得λ项是什么东西呢？它的原型是函数，但不是一般的函数。在定义λ项之时，我们允许它将任意的λ项转化为另一个λ项。既然是任意的λ项，那么当然也包括它自己。如果将λ项看成程序的话，那又是一个可以将自己当作输入数据的程序。与图灵机不同的是，在λ演算之中，根本没有数据和程序之分，一切都是λ项，它们既是程序，也是数据。</p>
<p>λ演算的能力不止于此。考虑所谓的Y组合子：</p>
<p><span class="MathJax_Preview">\( Y = \lambda x. \, (\lambda y. \, x \, (y \, y)) \, (\lambda y. \, x \, (y \, y)) \)</span><script type="math/tex"> Y = \lambda x. \, (\lambda y. \, x \, (y \, y)) \, (\lambda y. \, x \, (y \, y)) </script></p>
<p>将它应用到任意一个函数$f$时，我们会得到：</p>
<p><span class="MathJax_Preview">\( Y f \; = \; (\lambda x. \, (\lambda y. \, x \, (y \, y)) \, (\lambda y. \, x \, (y \, y))) \, f \)</span><script type="math/tex"> Y f \; = \; (\lambda x. \, (\lambda y. \, x \, (y \, y)) \, (\lambda y. \, x \, (y \, y))) \, f </script><br/>
<span class="MathJax_Preview">\( \rightarrow_{\beta} \; (\lambda y. \, f \, (y \, y)) \, (\lambda y. \, f \, (y \, y)) \)</span><script type="math/tex"> \rightarrow_{\beta} \; (\lambda y. \, f \, (y \, y)) \, (\lambda y. \, f \, (y \, y)) </script><br/>
<span class="MathJax_Preview">\( \rightarrow_{\beta} \; f \, ((\lambda y. \, f \, (y \, y)) \, (\lambda y. \, f \, (y \, y))) \)</span><script type="math/tex"> \rightarrow_{\beta} \; f \, ((\lambda y. \, f \, (y \, y)) \, (\lambda y. \, f \, (y \, y))) </script><br/>
<span class="MathJax_Preview">\( = \; f \, (Y \, f) \)</span><script type="math/tex"> = \; f \, (Y \, f) </script></p>
<p>这样不停替换下去，得到的结果就相当于将函数$f$应用到自身任意多次。λ演算的能力，特别是在自我指涉方面，于此可见一斑。</p>
<p>正是如此强大的表达能力，使得作为逻辑系统的λ演算一无所能。如果还记得图灵机是怎么在<a href="https://songshuhui.net/archives/75957" title="计算的极限（二）：自我指涉与不可判定" target="_blank">停机问题</a>上失效的话，实际上利用相似的技巧，对于任意的命题，我们可以构造一个λ演算中的证明，无论命题本身是对是错。</p>
<p>后来Curry的工作在更深刻的意义上揭示了这一点。他概括了λ演算的某些特性，然后证明了对于无论什么逻辑系统，只要它拥有这些特性，那么它必然是不一致的。而这些特性，也恰好是会碍事的那部分自我指涉所需要的。</p>
<p>于是，作为一个逻辑模型，λ演算一败涂地。</p>
<p>但丘奇没有就此止步。虽然λ演算不能如他所愿成为数学的推理基础，作为一个计算模型似乎倒也不错。我们可以将一个计算过程看成函数，将输入数据转化为输出数据的函数。于是丘奇将“可有效计算”定义为“可以用λ演算表达的函数”。这时，自我指涉的特性就成为了不可多得的优点，因为这实际上说明λ演算有强大的计算能力。利用自我指涉的特性，通过相似的构造方法，丘奇同样解决了希尔伯特的可判定性问题，得到了与图灵相同的结论。</p>
<p>丘奇在构想λ演算之时，瞄准的是更为基本的数学基础模型，但它却成为了可计算性的模型，真可谓“无心插柳柳成荫”。这就是图灵看到的那篇论文的由来。</p>
<p>不难想象图灵当时读到这篇论文时的心情。如果将数学比作攀山，当你千辛万苦登上一座处女峰，却蓦然发现山顶已经插上了别人的旗帜，你大概会觉得一切都似乎失去了意义。</p>
<p>但数学毕竟不是攀山，不同的路径可能有不同的景致，要论高下为时尚早。况且要比较两者，要先知道两者解决的到底是不是同一个问题。虽然图灵和丘奇解决的都是同一个问题，但他们对“可计算性”各自做了不同的假定。图灵认为“可计算的问题”就是图灵机可以解决的问题，而丘奇则认为那应该是λ演算可以解决的问题。</p>
<p>问题是，图灵机和λ演算这两个计算模型，它们解决问题的能力一样吗？两种视点下的可计算性，到底是殊途同归，还是貌合神离？</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算的极限（二）：自我指涉与不可判定]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-er-zi-wo-zhi-she-yu-bu-ke-pan-ding/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-er-zi-wo-zhi-she-yu-bu-ke-pan-ding/">
        </link>
        <updated>2021-01-13T17:13:57.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>计算无处不在。</p>
<p>走进一个机房，在服务器排成的一道道墙之间，听着风扇的鼓噪，似乎能嗅出0和1在CPU和内存之间不间断的流动。从算筹算盘，到今天的计算机，我们用作计算的工具终于开始量到质的飞跃。计算机能做的事情越来越多，甚至超越了它们的制造者。上个世纪末，深蓝凭借前所未有的搜索和判断棋局的能力，成为第一台战胜人类国际象棋世界冠军的计算机，但它的胜利仍然仰仗于人类大师赋予的丰富国际象棋知识；而仅仅十余年后，Watson却已经能凭借自己的算法，先“理解”问题，然后有的放矢地在海量的数据库中寻找关联的答案。长此以往，工具将必在更多的方面超越它的制造者。而这一切，都来源于越来越精巧的计算。</p>
<p>计算似乎无所不能，宛如新的上帝。但即使是这位“上帝”，也逃不脱逻辑设定的界限。</p>
<p>第一位发现这一点的，便是图灵。</p>
</blockquote>
<p>《<a href="/https://songshuhui.net/archives/tag/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90" target="_blank">计算的极限</a>》系列</p>
<h1>矛盾的自我指涉</h1>
<p>在现实中，证明某种东西不存在是非常困难的。要证明某种东西存在，只要举出一个例子就可以了；但要证明某种东西不存在，就要想办法排除所有的可能性，而在现实生活中，这几乎是不可能的。所以，只要能排除那些比较主要的可能性，任务就算完成。但在数学中，情况大不相同：通过形式逻辑的方法，我们可以确实地证明某种数学对象不存在。这都要归功于数学那彻底的抽象化和形式化。</p>
<p>数学家在证明某个数学对象不存在的时候，经常会来一招“欲擒故纵”：首先假设它存在，那么它必然具有某些特定的性质，再利用这些性质，用严密的逻辑推理引出一个不可能的结论。既然结论是不可能的，而逻辑推理又没有问题，那么一定是推理的出发点出了差错：作为推理基础的那个东西，其实并不存在。这种证明方法，就是反证法。</p>
<p>现在，我们尝试用反证法证明停机问题是不可计算的。</p>
<p>按照反证法的格式，我们先反其道而行之，假设停机问题是可以计算的。根据定义，这说明存在一台图灵机P，使得向它输入某个图灵机M的状态转移表编码，以及初始输入I，图灵机P就能在有限步运算内，判断出机器M在输入I上是否会停止。</p>
<p>接下来，我们将要用图灵机P构造一个逻辑上不可能存在的结构，这将是证明的关键。</p>
<p>我们来考虑一个新的图灵机R，它的输入是某个图灵机M的状态转移表编码&lt;M&gt;。图灵机R先“调用”图灵机P，判断图灵机M在初始输入&lt;M&gt;上是否会停止。用现代的计算机语言来说，就相当于调用函数P(&lt;M&gt;,&lt;M&gt;)。如果图灵机P得出的结论是机器M在输入&lt;M&gt;上会停止的话，图灵机R接下来就会进入死循环；否则，如果机器M在输入&lt;M&gt;上不会停机的话，图灵机R就停止。</p>
<figure data-type="image" tabindex="1"><img src="https://Xiqiu-li.github.io/post-images/1610558182486.png" alt="" loading="lazy"></figure>
<p>图灵机R的构造有两个奇怪之处。</p>
<p>首先，在图灵机R的运作中，它尝试判断一台图灵机M在它自身的编码&lt;M&gt;上的运作情况。此时，图灵机M不仅是程序，同时也是数据。这提醒我们，其实程序和数据没有实质的区别。程序只是一种特殊的数据，能够被分析、整理、改写。</p>
<p>事实上，我们每天都在使用处理程序的程序。比如说杀毒软件，其实就是一种扫描程序的程序。它检查每个程序的内容，判断程序中有没有威胁计算机安全的恶意代码。用杀毒软件扫描它自身，实际上就是让这个程序运作在它自身的代码之上。我们也可以用记事本打开记事本的程序本身，或者用压缩软件打一个包含它程序本身的压缩包。这些例子都说明了一个道理：程序就是一种数据。正因为程序就是数据，我们才得以完成图灵机的自我指涉。</p>
<p>其次，在图灵机R的构造中，如果M在输入&lt;M&gt;上停机，那么R就不停机；如果M在输入&lt;M&gt;上不停机，那么R就停机。这就是说谎者悖论的翻版：它的行为要与自己的判断相悖。</p>
<p>这样，我们就凑齐了说谎者悖论的两个要素：自我指涉和自我否定。剩下的，就是如何将这两个要素组合在一起，引出不可调和的矛盾了。</p>
<p>为了引出矛盾，我们来考虑图灵机R在自己的编码&lt;R&gt;上的运行情况。</p>
<p>如果R在&lt;R&gt;上停机的话，R必定没有进入死循环。所以，在调用图灵机P时，得到的必然是“图灵机R在输入&lt;R&gt;上不会停机”，才能避免死循环。但图灵机P的这个结论不符合我们的假设，出现了逻辑矛盾，所以R不可能在&lt;R&gt;上停机。</p>
<p>如果R在&lt;R&gt;上不停机的话，因为图灵机P必定在有限时间内完成计算，所以R必定进入了死循环。而R进入死循环的先决条件是，在调用图灵机P时，得到的是“图灵机R在输入&lt;R&gt;上停机”。而图灵机P的这个结论，同样不符合我们的假设。由于同样的逻辑矛盾，R同样不可能在&lt;R&gt;上不停机。</p>
<p>所以，根据严密的逻辑，我们构造的图灵机R在自己的编码&lt;R&gt;上，既不可能停机又不可能不停机，这是不可能的。另一方面，我们的逻辑推理也是没有问题的。尽管多么不情愿，剩下的可能性只有一种：我们假设的那个能完美解决停机问题的图灵机P，根本不存在！也就是说，停机问题是不可计算的。。</p>
<p>&nbsp;</p>
<figure data-type="image" tabindex="2"><img src="https://Xiqiu-li.github.io/post-images/1610558218808.jpg" alt="" loading="lazy"></figure>
<p style="text-align: center">【感谢neko（@iNEKO_mini）提供图片】</p>
<p>这个结论，我们称之为停机定理。以上的论述，作为停机定理的证明远远不算严谨，还有很多细枝末节需要填充。但这些细节都是技术性的，并不妨碍主要的思想：矛盾的自我指涉。</p>
<p>停机定理的证明，一如哥德尔不完备性定理的证明，核心是化了妆的说谎者悖论。图灵机的能力如此强大，一台通用图灵机就可以完成一切图灵机的工作，将所有图灵机作为数据处理。也正因如此，图灵机不能解决某些牵涉它自身的问题，否则总会存在一些自我否定的“说谎者”，利用能解决牵涉自身问题的那些图灵机，完成被逻辑所禁止的，致命的自我指涉。图灵机的能力，在必然的逻辑推演下，同时也成了它的枷锁。</p>
<h1>不可判定的重复</h1>
<p>实际上，图灵一开始并没有证明停机定理。他证明的是：不存在这样的程序，能判断任意图灵机是否会至少打印出一个1。这里的“1”可以换成任意的符号。这个证明的方法要稍复杂些，不过本质上仍然是通过自我否定与自我指涉来制造悖论。而事实上，许多（但不是所有）有关图灵机的问题，都能用同样的方法被证明是不可计算的。这样，图灵手上就握有一套不可计算的问题，可以开始进攻希尔伯特的问题。</p>
<p>我们回顾一下希尔伯特的问题。哥德尔证明了，所谓的“一阶谓词演算”是完备的。也就是说，在这个数学系统中，每个真理都能被证明，“真”和“能被证明”这两个概念是一致的。希尔伯特的可判定性问题是：是否存在一种计算过程，可以在有限步运算内，判断在这个完备的数学系统中每个命题的真假？</p>
<p>一阶谓词演算作为数学系统，在能力上实在是比不上数学家们常用的逻辑系统：它连自然数都不能很好地定义。但图灵发现，这个稍弱的数学系统已经足以表达图灵机的运行过程。对于每个图灵机M，通过巧妙然而机械化的操作，图灵都能构造出一阶谓词演算中的一个命题U(M)，使得U(M)成立当且仅当图灵机M会至少打印出一个1！也就是说，命题U(M)是否为真与图灵机M的运行过程息息相关。</p>
<p>剩下的证明就如同探囊取物了。如果希尔伯特的可判定性问题是可以计算的话，必定存在一台图灵机H，可以在有限时间内，判断每个命题的真假。对于一台图灵机M，我们要知道它是否会至少打印出一个1，可以先机械化地计算出与M有关的命题U(M)，然后用图灵机H去判断U(M)的真假，从而判断图灵机M是否会至少打印出一个1。也就是说，利用图灵机H，我们可以用计算回答一个不可计算的问题，而这是不可能的。所以，图灵机H并不存在，希尔伯特的可判定性问题的答案只有三个字：不可能。</p>
<p>希尔伯特的期望，又一次化为泡影。逻辑弄人。</p>
<p>图灵确信自己解决了希尔伯特的判定问题后，很快将他的想法写成了论文，它的题目是：</p>
<p>《<strong>论可计算数，及其在可判定性问题上的应用</strong>》（On Computable Numbers, With an Application to the Entscheidungsproblem）</p>
<p>他将论文交给了数理逻辑课的纽曼教授。这篇论文在纽曼教授的桌上放了几个星期。当教授终于有时间细读图灵的论文时，一开始根本不敢相信希尔伯特的问题竟然能通过对如此简单的机器的论证而解决，但无懈可击的逻辑论证最终战胜了怀疑。这无疑是划时代的工作，最终埋葬了希尔伯特的宏伟计划。</p>
<p>但正当纽曼教授联系各方，想办法发表图灵的论文时，从大西洋彼岸的普林斯顿，寄来了一篇论文：</p>
<p>《<strong>初等数论中的一个不可解问题</strong>》（An unsolvable problem of elementary number theory）</p>
<p>它的作者是丘奇（Alonzo Church），普林斯顿大学的一位年轻数学教授，当时在数理逻辑这一领域已经小有名气。而这篇文章的最后一句话是：</p>
<p>In particular, if the system of <em>Principia Mathematica</em> be ω-consistent, its Entscheidungsproblem is unsolvable.<br/>
（特别地，如果《数学原理》中的系统是ω-一致的话，它的可判定性问题是不可解的。）</p>
<p>对于图灵来说，这绝对不是一个好消息，因为这正是他的结果。</p>
<p>那么，丘奇又是如何得到这个结论的呢？</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算的极限（一）：所有机器的机器，与无法计算的问题]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-yi-suo-you-ji-qi-de-ji-qi-yu-wu-fa-ji-suan-de-wen-ti/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian-yi-suo-you-ji-qi-de-ji-qi-yu-wu-fa-ji-suan-de-wen-ti/">
        </link>
        <updated>2021-01-13T16:52:05.000Z</updated>
        <content type="html"><![CDATA[<blockquote>
<p>在图灵诞辰100周年之际，献给这位伟大的开拓者。</p>
<p>计算无处不在。</p>
<p>走进一个机房，在服务器排成的一道道墙之间，听着风扇的鼓噪，似乎能嗅出0和1在CPU和内存之间不间断的流动。从算筹算盘，到今天的计算机，我们用作计算的工具终于开始量到质的飞跃。计算机能做的事情越来越多，甚至超越了它们的制造者。上个世纪末，深蓝凭借前所未有的搜索和判断棋局的能力，成为第一台战胜人类国际象棋世界冠军的计算机，但它的胜利仍然仰仗于人类大师赋予的丰富国际象棋知识；而仅仅十余年后，Watson却已经能凭借自己的算法，先“理解”问题，然后有的放矢地在海量的数据库中寻找关联的答案。长此以往，工具将必在更多的方面超越它的制造者。而这一切，都来源于越来越精巧的计算。</p>
<p>计算似乎无所不能，宛如新的上帝。但即使是这位“上帝”，也逃不脱逻辑设定的界限。</p>
<p>第一位发现这一点的，便是图灵。<br/>
</blockquote>
<p>《<a href="https://songshuhui.net/archives/tag/%E8%AE%A1%E7%AE%97%E7%9A%84%E6%9E%81%E9%99%90" target="_blank">计算的极限</a>》系列</p>
<h1>所有机器的机器</h1>
<p>图灵机非常简单，只要明白了它的运作过程，任何一个受过足够训练的计算机系本科生都可以写出一个模拟图灵机运行的程序。只消输入状态转移表和纸带的输入内容，程序就可以一步一步模拟相应的图灵机在纸带上爬来爬去的过程。对于一些熟悉图形编程的程序员来说，做个模拟动画也问题不大。即使不用计算机，靠人手一步步操作，也是一件小孩子也能完成的事。图灵机就是这么简单的一种机器。</p>
<p>虽然看上去简单，但实际上图灵机能做的事情远远超出一般的想象。只要有足够长的纸带和足够好的耐心，今天的电脑能做的计算，一台精心设计的图灵机也能完成。诀窍在于，电脑中的电路是有限的，电路的状态也是有限的，我们可以用图灵机去模拟电脑中的电路状态。只要有足够长的纸带，那就可以模拟出足够大的寄存器、内存和硬盘；而CPU中的电路，虽然所有可能的状态极其多，但终究是有限的，可以用图灵机模拟，虽然这台图灵机的状态转移表将会有着令人头痛的大小，以及令人偏头痛的复杂程度。但是，从原则上来说，用图灵机模拟一台电脑是完全可能的，虽然每次“读写内存”时，读写头都需要花长得令人咋舌的时间在纸带上来回奔波。</p>
<p>也就是说，从原则上来说，只要配备适当的输入和输出设备，以及极其好的耐心，我们完全可以用图灵机上网、玩游戏甚至执行自己写的程序。特别地，存在一台特定的编写程序专用的图灵机T，我们可以在纸带上写程序，将它输入到T，然后T就能执行这个程序。那么，如果我们将方才本科生写的那个可以模拟任意图灵机运行的程序（暂且把它称为程序P），写在纸带上输入到T中，让T去执行的话，原本的机器T就摇身一变，变成了一台可以根据输入的状态转移表来模拟任何一台图灵机的图灵机。</p>
<figure data-type="image" tabindex="1"><img src="https://Xiqiu-li.github.io/post-images/1610557515850.jpg" alt="" loading="lazy"></figure>
<p style="text-align: center;">【乐高玩具版图灵机，图片出处：http://www.cs.cmu.edu/】</p>
<p>更精确地说，因为程序P的长度是有限的，我们可以将它直接写进原来机器的状态转移表，得到一台新的机器UTM。UTM会在纸带上读取两样东西：一台图灵机M的状态转移表的二进制编码，以及作为M的初始输入的纸带数据。然后，UTM会根据M的状态转移表和初始输入数据，在纸带上模拟M的运作过程。换言之，UTM是一台可以模拟任何图灵机的图灵机。它是所有机器的机器，所谓的通用图灵机（Universal Turing Machine）。当然，通用图灵机并不是唯一的，只要一台图灵机能完成根据状态转移表模拟任意图灵机的任务，它就是通用图灵机。</p>
<figure data-type="image" tabindex="2"><img src="https://Xiqiu-li.github.io/post-images/1610557569438.png" alt="" loading="lazy"></figure>
<p style="text-align: center;">【一台通用图灵机，数据具体格式请参见来源：http://rendell-attic.org/gol/utm/utmprog.htm】</p>
<p>通用图灵机的想法，在如今这个计算机泛滥的时代，似乎并不新鲜。但在图灵的1935年，电子计算机甚至仍未问世，机械计算机还只能执行内设的一套指令。即使是Charles Babbage和Ada Lovelace的超越时代的设想，其中执行外部程序的概念也相当含混不清。在这种历史背景下，要归纳出通用图灵机这个概念，本身就需要极为丰富的想象力，而且这种图灵机是否存在，这是个远非显然的问题。而图灵不仅设想到了这个概念，而且正确地判断出它的存在性，这需要何等非凡的直觉！</p>
<p>但单纯的直觉终究不能令人信服，数学家讲究的是逻辑和证明。而要证明通用图灵机的存在，最直接的方法莫过于直接给出一个通用图灵机的实例。这并不简单，如果读者想尝试一下的话，我建议先尝试构造一个能做二进制加法的图灵机。为了降低难度，可以假设纸带上有第三种符号，表示空白，但即使如此，要构造一个能做加法的图灵机，远比想象中的困难。可想而知，通用图灵机的构造肯定更为复杂繁琐。即使是图灵，他在一开始给出的构造也是有问题的，而这些问题甚至在后来的勘误中也没有成功修正。比构造更麻烦的是证明给出的图灵机的确是一台通用图灵机，在图灵解决希尔伯特可判定性问题的论文中，有关通用图灵机的构造和证明占了相当大的篇幅。这部分非常繁复琐碎，而且其中还有错误，如果细细研读的话，绝对有诱发剧烈偏头痛的危险。</p>
<p>幸运的是，无论细节多么复杂，图灵的想法还是被逻辑学家们接受了。一旦领会到图灵机的能力，接受了通用图灵机的构想，再检查几个能完成基本任务的图灵机之后，大部分数学家都会认为通用图灵机的确存在，尽管他们并不一定会细看图灵的详细构造。而现代电子计算机的发展，更是验证了通用图灵机的存在：每一台电脑都相当于一台通用图灵机。</p>
<p>通用图灵机的存在，从侧面说明了图灵机这个计算模型的强大之处：图灵机作为一类机器，其中一个特例就可以模拟整个类别中的任意一台机器，宛如能折射大千世界的一滴水珠。但在这种强大的背后，隐隐也暗藏着不安定的因素。哥德尔不完备性定理告诉我们，有时候越强大的数学理论，因为能表达的概念太多，甚至连理论的命题和证明都能表达，反而会导致不能被证明的真命题的存在。如果一个系统足以描述它自己，那魔法般的自指将是不可避免的。图灵机如此强大，它的其中一台就可以模拟所有图灵机，会不会导致不能用计算来回答的问题存在呢？</p>
<p>很不凑巧，答案是会。</p>
<h1>无法计算的问题</h1>
<p>在哥德尔不完备性定理的证明中，哥德尔构造了一个描述了本身不可证明性的自指命题，通过这个命题完成了他的证明。要想照葫芦画瓢的话，那些关于图灵机本身的问题，将会是很好的候补。</p>
<p>关于图灵机，最简单的问题是什么呢？回想一下图灵机的运作过程，一台图灵机从初始状态开始，根据纸带上的内容，一边不断变换状态，一边更改纸带的内容，如此往复永无休止，除非它遇上了表示停机的那个状态，才能从这机械的计算过程中跳出，获得静息的安乐。一个自然的问题是：一台图灵机什么时候会停机呢？</p>
<p>更严格地说，会不会停机并不是图灵机本身的属性，它跟纸带的初始输入也有关系。对于同一台图灵机，不同的纸带输入也可能导致不同的结果和行为。比如说，我可以设计一台图灵机，它的任务只有一个：一步一步向右移动，寻找输入中的第一个1。如果输入纸带上全是0的话，那么，这台图灵机自然不会停止；但只要纸带上有一个1，那么它就会停止。所以，真正严谨的问题是：给定一台图灵机M以及一个输入I，如果我们将I输入M，然后让M开始运行，这时M是会不停运转下去，还是会在一段时间后停止？我们将这个问题称为停机问题。</p>
<p>初看起来，停机问题并不难。既然我们有通用图灵机这一强大的武器，那么只需要用它一步步模拟M在输入I上的计算过程就可以了。如果模拟过程在一段时间后停止了，我们当然可以得出“M在输入I上会停止”这个结论。问题是，在模拟过程停止之前，我们不可能知道整个计算过程到底是不会停止，它可能会在3分钟后停止，可能要等上十年八载，更有可能永远都不会停止。换句话说，用模拟的方法，我们只能知道某个程序在某个输入上会停止，但永远不能确定那些不停止的状况。所以说，单纯的模拟是不能解决停机问题的。</p>
<p>实际上，停机问题比我们想象中要复杂得多。</p>
<p>举个例子，我们可以编写一个程序GC，它遍历所有大于等于6的偶数，尝试将这样的偶数分成两个素数的和。如果它遇到一个不能被分解为两个素数之和的偶数，它就停机并输出这个偶数；否则，它就一直运行下去。用现代的工具编写GC这样的程序，对于计算机系的学生最多只能算一次大作业；用图灵机实现的话，也不是什么极端困难的事。然而，GC是否会停止可是牵涉到了哥德巴赫猜想。如果哥德巴赫猜想是正确的，每个大于等于6的偶数都能分解为两个素数之和的话，那么GC自然会一直运行下去，不会停机；如果哥德巴赫猜想是错误的话，必定存在一个最小的反例，它不能分解为两个素数之和，而GC在遇到这个反例时就会停机。也就是说，GC是否永远运行下去，等价于哥德巴赫猜想是否成立。如果我们能判定GC是否会停止，那我们就解决了哥德巴赫猜想。</p>
<p>数学中的很多猜想，比如说3x+1猜想、黎曼猜想等，都可以用类似的方法转化为判断一个程序是否会停止的问题。如果存在一个程序，能判断所有可能的图灵机在所有可能的输入上是否会停止的话，那么只要利用这个程序，我们就能证明一大堆重要的数学猜想。我们可以说，停机问题比所有这些猜想更难更复杂，因为这些困难的数学猜想都不过是一般的停机问题的一个特例。如果停机问题可以被完全解决，我们能写出一个程序来判断任意图灵机是否会停机的话，那么相当多的数学家都要丢饭碗了。</p>
<p>停机问题如此复杂，机械的计算看起来没有足够的力量来完全解决它。停机问题似乎是不可计算的。但要想严格证明这个结论，似乎仍要求助于深藏在图灵机之中，那魔法般的自指。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[计算的极限]]></title>
        <id>https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian/</id>
        <link href="https://Xiqiu-li.github.io/post/ji-suan-de-ji-xian/">
        </link>
        <updated>2021-01-13T16:33:00.000Z</updated>
        <content type="html"><![CDATA[<p>计算的极限系列原本是由<a href="https://songshuhui.net/archives/author/fwjmath/">方弦</a>发表在<a href="songshuhui.net">松鼠会</a>的一系列文章，但松鼠会网站因不明原因以无法访问，因此将在此转载此系列文章。</p>
<h2 id="转载">转载</h2>
<p><a href="https://xiqiu-li.github.io/post/ji-suan-de-ji-xian-ling-luo-ji-yu-tu-ling-ji/">计算的极限（零）：逻辑与图灵机</a></p>
<h2 id="原文">原文</h2>
<p><a href="https://songshuhui.net/archives/70194">计算的极限（零）：逻辑与图灵机</a></p>
<p><a href="https://songshuhui.net/archives/75175">计算的极限（一）：所有机器的机器，与无法计算的问题</a></p>
<p><a href="https://songshuhui.net/archives/75957">计算的极限（二）：自我指涉与不可判定</a></p>
<p><a href="https://songshuhui.net/archives/80229">计算的极限（三）：函数构成的世界</a></p>
<p><a href="https://songshuhui.net/archives/85861">计算的极限（四）：机械计算的圭臬</a></p>
<p><a href="https://songshuhui.net/archives/89734">计算的极限（五）：有限的障壁</a></p>
<p><a href="https://songshuhui.net/archives/90745">计算的极限（六）：无穷的彼岸</a></p>
<p><a href="https://songshuhui.net/archives/92392">计算的极限（七）：宛如神谕</a></p>
<p><a href="https://songshuhui.net/archives/93188">计算的极限（八）：符号的框架</a></p>
<p><a href="https://songshuhui.net/archives/93245">计算的极限（九）：叹息与奋斗</a></p>
<p><a href="https://songshuhui.net/archives/93311">计算的极限（十）：无限绵延的层级</a></p>
<p><a href="https://songshuhui.net/archives/93368">计算的极限（十一）：黄金时代</a></p>
<p><a href="https://songshuhui.net/archives/93698">计算的极限（十二）：不会出错的程序</a></p>
<p><a href="https://songshuhui.net/archives/97690">计算的极限（十三）：数字空间的幽灵</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[产生式]]></title>
        <id>https://Xiqiu-li.github.io/post/chan-sheng-shi/</id>
        <link href="https://Xiqiu-li.github.io/post/chan-sheng-shi/">
        </link>
        <updated>2021-01-13T07:22:14.000Z</updated>
        <content type="html"><![CDATA[<p>产生式是POST提出的根据一种规则，计算模型POST机的串替代规则就是产生式。<br>
写作<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi><mo>→</mo><mi>Q</mi></mrow><annotation encoding="application/x-tex">P\to Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[相继式演算]]></title>
        <id>https://Xiqiu-li.github.io/post/xiang-ji-shi-yan-suan/</id>
        <link href="https://Xiqiu-li.github.io/post/xiang-ji-shi-yan-suan/">
        </link>
        <updated>2021-01-13T02:07:42.000Z</updated>
        <content type="html"><![CDATA[<p>相继式演算式可证明的形式陈述。是一阶逻辑的演绎系统。</p>
<p>「LK系统」「Gentzen系统」</p>
<p>相继式的一般形式为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Gamma\vdash\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span><br>
<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>⊢</mo></mrow><annotation encoding="application/x-tex">\vdash</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mrel">⊢</span></span></span></span>被称作十字转门，读作“产生”或“证明”，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>叫做相继式的前件，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>叫做相继式的后继。<br>
相继式的LHS（左手端）是合取，RHS（右手端）是析取。当LHS为空，此相继式是重言式。</p>
<p>因为在（左边的）的前件中的所有公式都必须为真来获得在（右边的）后继中至少一个公式为真，向任何一端增加公式都导致一个更弱的相继式，而从任何一端去除公式都得到更强的相继式。</p>
<p>多数证明系统都提供从一个相继式到另一个相继式的演绎方式。这些规则都写成在横线上下的相继式列表。这些规则指示如果在横线上的所有相继式都为真，则在横线之下的也都为真。</p>
<p>一个典型的规则是：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mfrac><mrow><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi>α</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>α</mi><mo separator="true">,</mo><mi mathvariant="normal">Γ</mi><mo>⊢</mo><mi mathvariant="normal">Σ</mi></mrow></mstyle></mtd></mtr></mtable></mfrac></mrow><annotation encoding="application/x-tex">{\Gamma\vdash\Sigma} \over {\begin{matrix} \Gamma,\alpha\vdash\Sigma &amp; \alpha,\Gamma\vdash\Sigma \end{matrix}}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.46144em;vertical-align:-1.09em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.37144em;"><span style="top:-2.26em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8500000000000001em;"><span style="top:-3.01em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.35000000000000003em;"><span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">Γ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⊢</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">Σ</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.09em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>这指示了如果我们可以演绎<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>，则我们也可以演绎它自<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.0037em;">α</span></span></span></span>一起。</p>
<p>注意我们通常使用大写的希腊字母来指称（可能为空）公式的列表。<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi mathvariant="normal">Γ</mi><mo separator="true">,</mo><mi mathvariant="normal">Σ</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[\Gamma,\Sigma]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">Γ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">Σ</span><span class="mclose">]</span></span></span></span>被用来指示<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>的紧缩，就是说，这些出现在要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span>要么<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Σ</mi></mrow><annotation encoding="application/x-tex">\Sigma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Σ</span></span></span></span>中但不重复的那些公式的列表。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MarkDown]]></title>
        <id>https://Xiqiu-li.github.io/post/markdown/</id>
        <link href="https://Xiqiu-li.github.io/post/markdown/">
        </link>
        <updated>2021-01-13T01:58:26.000Z</updated>
        <content type="html"><![CDATA[<p>markdown可以和html混合使用<br>
一个很重要的教程是<a href="https://www.w3school.com.cn/">w3school</a></p>
<p>MarkDown输入数学符号<br>
Mathjax<br>
输入<code>$…$</code>显示Latex，<code>$$…$$</code>单独显示。<br>
<code>\Gamma</code>显示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">Γ</mi></mrow><annotation encoding="application/x-tex">\Gamma</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">Γ</span></span></span></span><br>
<code>$x_{3^2}$</code>显示为<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><msup><mn>3</mn><mn>2</mn></msup></msub></mrow><annotation encoding="application/x-tex">x_{3^2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6081799999999999em;vertical-align:-0.17762em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em;"><span style="top:-2.52238em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mtight">3</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7463142857142857em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.17762em;"><span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>a</mi><mn>2</mn></msup><mo>=</mo><msup><mi>b</mi><mn>2</mn></msup><mo>+</mo><msup><mi>c</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">a^2 = b^2 + c^2
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.9474379999999999em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">b</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8641079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">c</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></span></p>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Expected &#039;EOF&#039;, got &#039;&amp;&#039; at position 4: A  &amp;̲ \to  B \tag{规则…'>A  &amp; \to  B \tag{规则1} \\
&amp; a \tag{规则2} \\
</p>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<hr>
<p><strong>粗体</strong><br>
<strong>粗体</strong><br>
<em>斜体</em><br>
<em>斜体</em><br>
<em><strong>粗斜</strong></em></p>
<blockquote>
<p>块引用</p>
</blockquote>
<blockquote>
<p>连续块</p>
</blockquote>
<pre><code>&lt;html&gt;
    &lt;head&gt;
     代码块
    &lt;/head&gt;
&lt;/html&gt;
</code></pre>
<p>分割线</p>
<hr>
<hr>
<hr>
<p>超链接<a href="https://markdown.com.cn" title="最好的markdown教程">Markdown语法</a></p>
<p>引用MarkDown语法<a href="https://markdown.com.cn/basic-syntax/links.html">1</a></p>
<p>图片</p>
<figure data-type="image" tabindex="1"><img src="/assets/img/philly-magic-garden.jpg" alt="这是图片" title="Magic Gardens" loading="lazy"></figure>
<h2 id="reference">reference</h2>
<p><a href="http://www.yinwang.org/blog-cn/2013/04/14/markdown">Markdown 的一些问题</a></p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Markup Language]]></title>
        <id>https://Xiqiu-li.github.io/post/markup-language/</id>
        <link href="https://Xiqiu-li.github.io/post/markup-language/">
        </link>
        <updated>2021-01-12T15:16:36.000Z</updated>
        <content type="html"><![CDATA[<p>著名的标记语言有</p>
<li>
HTML
</li>
<li>
MarkDown
</li>
<li>
Tex
</li>
<h2 id="html">HTML</h2>
<p>HTML是当代互联网创建网页的通用标记语言，由一系列&lt;&gt;标签进行标记。由3W联盟制定标准。3W还有一个被称作”语义网“的计划，私以为和HTML密切相关。在H5的制定标准中，HTML的标签更倾向于语义描述而不是样式描述。江湖传言中真正的高手直接使用HTML编写自己的博客，而假使遵循“所见即所指”的原则，编写HTML只需要关心文本的内涵，而无需关注他们的显示样式。看似美好，但这里有一个严重问题，就是每次编写一段内容的时候都要输入各种标签，有时还需要标明特定的class或者标签的id，非常繁琐。</p>
<h2 id="markdown">MarkDown</h2>
<p>MarkDown一般使用方式均为翻译为HTML在网页显示。所以一般MarkDown能实现的均可以使用HTML实现。MakrDown属于内容和格式分离的标记语言，因此不能操作一些格式上的问题，想要操作格式需要使用css的技巧。另外MarkDown的官方标准最新更新是在2004年，至今MarkDown虽然被很多平台采用，但不同平台的实现各有不同，因此移植性较差。此外MarkDown还有一些语言本身的问题</p>
<li>
layout语法空格敏感
</li>
<li>
特殊字符选择不合理，如*被用于做标记。
</li>
因MarkDown一般都是转换成HTML使用，因此可尝试自己设计一下修改MarkDown的语法为自己平日编辑做转换。
<h2 id="tex">Tex</h2>
<p>Tex是高德纳发明的一种排版系统，可以输出多种文件格式，可以显示多种符号。纸张的写法在二维平面内不受限制，而计算机只能输入制定编码以特定形式展现，键盘只有有限且固定的键位，因此想要输入各种在纸张时代设计的数学符号公式、化学结构式等复杂的结构，就必须有一套强大的编辑系统。只有如此才能在计算机内编辑出想要的文章。而Tex的问题正是在于其复杂的功能所带来的学习难度。</p>
<h2 id="总结">总结</h2>
<p>虽然HTML提供了<code>&lt;math&gt;</code>标签做各种数学公式的表示，但仍有不足，而MarkDown自然不会更好。现有很多平台的编辑器疑似采用了Tex引擎，在用户输入内容后，后台将用户的源码中的公式按既定语法转换成图片后嵌入HTML，这对于自己写博客来说似乎有点糟糕。</p>
]]></content>
    </entry>
</feed>